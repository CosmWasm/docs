---
tags: ["multitest", "getting started", "counter", "CosmWasm"]
---

import { Callout, Card, Cards } from "nextra/components";

# Counter written in CosmWasm

## Counter source code

The following code snippets present the content of [**Cargo.toml**](#cargotoml),
[**lib.rs**](#librs), [**msg.rs**](#msgrs), and [**contract.rs**](#contractrs) files, respectively.
YouÂ can just copy and paste the provided content to previously created empty files, temporarily
skipping the detailed explanations. However, if you're curious about what happens inside each file,
feel free to check the detailed explanations provided for each code snippet.

### Cargo.toml

```toml showLineNumbers filename="Cargo.toml" copy
[package]
name = "counter"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib", "rlib"]

[features]
# use library feature to disable all instantiate/execute/query exports
library = []

[dependencies]
cosmwasm-schema = "2"
cosmwasm-std = { version = "2" }
cw-storage-plus = "2"
schemars = "0.8"
serde = "1.0"

[dev-dependencies]
cw-multi-test = { version = "2", features = ["cosmwasm_2_0"] }
```

**Detailed explanation**

<Cards>
  <Card title="ðŸ¦˜Â Â Skip this time" href="#librs" icon="" children="" />
</Cards>

`Cargo.toml` file is a configuration file for a Rust project, in our case for a smart contract
written in Rust. Here's a detailed explanation of each section and what it's doing.

**\[package\]**

```toml showLineNumbers{1} filename="Cargo.toml" copy
[package]
name = "counter"
version = "0.1.0"
edition = "2021"
```

- `[package]` section provides metadata about the Rust package (smart contract library in our case).
- `name = "counter"` specifies the name of the package, it's named **counter** like our smart
  contract.
- `version = "0.1.0"` indicates the current version of the package and the counter smart contract.
- `edition = "2021"` specifies the Rust edition being used; editions in Rust are sets of language
  and compiler improvements, with 2021 being one of the latest editions at the time, providing the
  latest features and enhancements.

**\[lib\]**

```toml showLineNumbers{8} filename="Cargo.toml" copy
[lib]
crate-type = ["cdylib", "rlib"]
```

- `[lib]` section specifies settings for building the library.
- `crate-type` enumerates types of libraries to be produced during compiling.
- `"cdylib"` specifies that the package will be compiled as a C-compatible dynamic library; which is
  required for smart contracts to run on the CosmWasm runtime.
- `"rlib"` specifies a Rust library file that can be used as a dependency for other Rust projects,
  in our case for other smart contracts.

**\[features\]**

```toml showLineNumbers{11} filename="Cargo.toml" copy
[features]
# use library feature to disable all instantiate/execute/query exports
library = []
```

- `[features]` section defines optional features for the Rust package.
- `library = []` defines a feature named "library", which by convention disables exporting smart
  contract entry-points when set.

**\[dependencies\]**

```toml showLineNumbers{15} filename="Cargo.toml" copy
[dependencies]
cosmwasm-schema = "2"
cosmwasm-std = { version = "2" }
cw-storage-plus = "2"
schemars = "0.8"
serde = "1.0"
```

- `[dependencies]` section lists the libraries that the package depends on.
- `cosmwasm-schema` is used for generating JSON schemas from Rust data structures, which is useful
  for documentation and ensuring compatibility of messages and queries.
- `cosmwasm-std` is the standard library for CosmWasm contracts, providing common types and
  utilities needed for interacting with the CosmWasm runtime.
- `cw-storage-plus` is a library that provides advanced storage abstractions and utilities on top of
  the basic storage capabilities in CosmWasm, making it easier to manage state within contracts.
- `schemars` is a library for generating JSON schemas, which complements `cosmwasm-schema` by
  providing additional features for schema generation.
- `serde` is a widely used serialization library in Rust, allowing easy conversion of Rust data
  structures to and from formats like JSON, which is crucial for data interchange in smart
  contracts.

**\[dev-dependencies\]**

```toml showLineNumbers{22} filename="Cargo.toml" copy
[dev-dependencies]
cw-multi-test = { version = "2", features = ["cosmwasm_2_0"] }
```

- `[dev-dependencies]` section lists dependencies that are only needed for development and testing.
- `cw-multi-test` is a name of **`MultiTest`** library, and should **ALWAYS**Â ðŸš¨ be placed in
  `[dev-dependencies]` section.

Overall, this Cargo.toml file configures a Rust project for a CosmWasm-based smart contract. It sets
up the basic package details, specifies how the contract should be compiled, defines dependencies
for core functionality and testing, and includes features to enable or disable certain parts of the
contract code. This setup ensures the contract can be developed, tested, and deployed effectively
within the CosmWasm ecosystem.

---

### lib.rs

```rust filename="lib.rs" copy
pub mod contract;
pub mod msg;
```

**Detailed explanation**

<Cards>
  <Card title="ðŸ¦˜Â Â Skip this time" href="#msgrs" icon="" children="" />
</Cards>

(todo: extremely detailed explanation)

### msg.rs

```rust filename="msg.rs" copy
use cosmwasm_schema::cw_serde;

#[cw_serde]
pub enum CounterInitMsg {
    Zero,
    Set(u8),
}

#[cw_serde]
pub enum CounterActionMsg {
    Inc,
    Dec,
    Set(u8),
}

#[cw_serde]
pub enum CounterQuery {
    Value,
}

#[cw_serde]
pub struct CounterResponse {
    pub value: u8,
}
```

**Detailed explanation**

<Cards>
  <Card title="ðŸ¦˜Â Â Skip this time" href="#contractrs" icon="" children="" />
</Cards>

(todo: extremely detailed explanation)

### contract.rs

```rust filename="contract.rs" copy
#[cfg(not(feature = "library"))]
use cosmwasm_std::entry_point;

use crate::msg::{CounterActionMsg, CounterInitMsg, CounterQuery, CounterResponse};
use cosmwasm_std::{to_json_binary, Binary, Deps, DepsMut, Env, MessageInfo, Response, StdError};
use cw_storage_plus::Item;

const COUNTER: Item<u8> = Item::new("value");

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn instantiate(
    deps: DepsMut,
    _env: Env,
    _info: MessageInfo,
    msg: CounterInitMsg,
) -> Result<Response, StdError> {
    COUNTER.save(
        deps.storage,
        &match msg {
            CounterInitMsg::Zero => 0,
            CounterInitMsg::Set(value) => value,
        },
    )?;
    Ok(Response::default())
}

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn execute(
    deps: DepsMut,
    _env: Env,
    _info: MessageInfo,
    msg: CounterActionMsg,
) -> Result<Response, StdError> {
    COUNTER.update::<_, StdError>(deps.storage, |old_value| {
        Ok(match msg {
            CounterActionMsg::Inc => old_value.saturating_add(1),
            CounterActionMsg::Dec => old_value.saturating_sub(1),
            CounterActionMsg::Set(new_value) => new_value,
        })
    })?;
    Ok(Response::default())
}

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn query(deps: Deps, _env: Env, msg: CounterQuery) -> Result<Binary, StdError> {
    match msg {
        CounterQuery::Value => Ok(to_json_binary(&CounterResponse {
            value: COUNTER.may_load(deps.storage).unwrap().unwrap(),
        })?),
    }
}
```

**Detailed explanation**

<Cards>
  <Card title="ðŸ¦˜Â Â Skip this time" href="#what-next" icon="" children="" />
</Cards>

(todo: extremely detailed explanation)

## What next?

Having the **counter** smart contract ready, you can begin [writing tests](../writing-tests) using
**`MultiTest`**.

Or you can check the Sylvia version.

(todo: add cards here)
