---
tags: ["core", "specification", "instantiate2"]
---

import { Callout } from "nextra/components";

[sha2]: https://crates.io/crates/sha2

# Instantiate2 algorithm

With the instantiate2 algorithm you can create a contract address in a predictable and deterministic
way. The underlying algorithm is rather simple.

We use SHA-256 as the underlying hashing algorithm.

You need to provide the following inputs:

- **checksum**: this is the checksum of the contract code (the Wasm module, for example). This has
  to be a SHA-256 hash,
- **creator**: this is the canonicalized address of the user instantiating the contract,
- **salt**: this is some byte string allowing you to distinguish multiple instantiations of the same
  contract by the same creator; this parameter has to be under 64 bytes in length,
- **message**: this is usually unused; CosmWasm sets this to an empty byte string.

<Callout emoji="🖝">
  Make sure you convert all the integers into their **big-endian** byte representation!
</Callout>

```rust filename="instantiate2.rs" template="instantiate2-spec"
let c_checksum = concat!((checksum.len() as u64).to_be_bytes(), checksum);
let c_creator = concat!((creator.len() as u64).to_be_bytes(), creator);
let c_salt = concat!((salt.len() as u64).to_be_bytes(), salt);
let c_msg = concat!((msg.len() as u64).to_be_bytes(), msg);

let canonical_address = hash_sha256(
    concat!(
        hash_sha256(b"module"),
        b"wasm\0",
        c_checksum,
        c_creator,
        c_salt,
        c_msg,
    ),
);
```

---

> My proposal

The example implementation in Rust, using [sha2] crate is shown in the following code snippet:

```rust copy filename="instantiate.rs" /checksum/ /creator/ /salt/ /msg/
use cosmwasm_std::CanonicalAddr;
use sha2::digest::Update;
use sha2::{Digest, Sha256};

fn instantiate2(checksum: &[u8], creator: &[u8], salt: &[u8], msg: &[u8]) -> CanonicalAddr {
    use sha2::digest::Update;
    use sha2::{Digest, Sha256};

    Sha256::new()
        .chain(Sha256::digest(b"module"))
        .chain(b"wasm\0")
        .chain((checksum.len() as u64).to_be_bytes())
        .chain(checksum)
        .chain((creator.len() as u64).to_be_bytes())
        .chain(creator)
        .chain((salt.len() as u64).to_be_bytes())
        .chain(salt)
        .chain((msg.len() as u64).to_be_bytes())
        .chain(msg)
        .finalize()
        .to_vec()
        .into()
}
```

<Callout emoji="🖝">
  Make sure you convert all integers into their **big-endian** byte representation!
</Callout>

<Callout>Note that all lengths are converted to 64-bit unsigned integers.</Callout>
