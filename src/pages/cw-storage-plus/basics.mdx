import { Callout } from "nextra/components";

# Basics

## Containers

_cw-storage-plus_ provides a number of storage containers that can be used to
store data on the blockchain. The fundamental ones are

- [`Item`](containers/item),
- [`Map`](containers/map),
- [`Deque`](containers/deque).

An [`Item`](containers/item) is a simple container that stores a single value.
The other two are a little more involved - they are collections capable of
storing multiple values, and provide several methods to interact with them.

## Keys and prefixes

One task of a storage library like `cw-storage-plus` is to manage the namespace
of keys provided by the blockchain.

When constructing a container, you must provide a key of type `&'static str`.
This usually means you'll be providing a string literal or some constant.

In the case of an [`Item`](containers/item), the provided key is the exact key
(a standard UTF-8 string) under which the value will be saved. In the case of
collections, the provided key is really a prefix; the collection will use this
prefix to generate keys (by appending to it) for the individual values it
stores.

As a contract dev, it is your responsibility to ensure that the keys you provide
are unique and do not conflict with keys used by other parts of the contract.

<Callout>
  Over time, we've learned that using long keys hurts storage performance. If
  you _gotta go fast_, a good approach might be to only provide single-character
  ASCII prefixes for your containers, like _"a"_, _"b"_, _"c"_, etc.
</Callout>

Generally speaking, we tried to make it so that as long as you use a unique
prefix for each container, you shouldn't have to worry about key conflicts.

TODO: Research the key collisions in the warning below more! Then we can provide
better advice.

<Callout type="warning">
  ...yet there's a small _but_. A `Map`'s prefix is length-prefixed. An `Item`
  is saved without any sort of length-prefixing of the key. It is, in theory,
  possible for an `Item`'s key to conflict with one of the keys generated by a
  `Map` or `Deque`. In practice, this is unlikely unless you use very long
  prefixes or start your `Item`'s key with the ‚êÄ ASCII character. Probably don't
  do that!
</Callout>

## Values

In `cw-storage-plus`, every value is saved using JSON serialization. For that to
be possible, only types that implement
[`serde::Serialize`](https://docs.rs/serde/1.0.201/serde/trait.Serialize.html)
and
[`serde::Deserialize`](https://docs.rs/serde/1.0.201/serde/trait.Deserialize.html)
are allowed.

Most of the Rust standard library types already implement these traits.
Additionally, types you'll find in `cosmwasm_std` (like
[`Addr`](https://docs.rs/cosmwasm-std/2.0.3/cosmwasm_std/struct.Addr.html),
[`Decimal`](https://docs.rs/cosmwasm-std/2.0.3/cosmwasm_std/struct.Decimal.html),
[`Binary`](https://docs.rs/cosmwasm-std/2.0.3/cosmwasm_std/struct.Binary.html)
or [`Coin`](https://docs.rs/cosmwasm-std/2.0.3/cosmwasm_std/struct.Coin.html))
often do as well.

If you're writing a custom type and wish to send it across call or put it in
storage, you'll have to derive these traits.

<Callout>
  *cw-storage-plus* uses
  [*serde-json-wasm*](https://github.com/CosmWasm/serde-json-wasm) under the
  hood. This provides determinism in some corners -
  [*serde_json*](https://github.com/serde-rs/json) would not be suited for the
  blockchain world!
</Callout>
