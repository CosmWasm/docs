---
tags: ["multitest", "getting started", "tests", "CosmWasm"]
---

import { Callout, Card, Cards } from "nextra/components";

[cargo-nextest]: https://nexte.st

# Writing tests in CosmWasm

As a reminder, the file structure of the **counter** project is shown below. In this chapter, you
will write tests for this smart contract, which should be placed in a file named `test_counter.rs`,
as highlighted on line 12.

```ansi {12} showLineNumbers filename="counter (directory)"
[34;1m.[0m
├── Cargo.toml
├── [32;1mcoverage.sh[0m
├── [34;1msrc[0m
│   ├── contract.rs
│   ├── lib.rs
│   └── msg.rs
└── [34;1mtests[0m
    ├── mod.rs
    └── [34;1mmultitest[0m
        ├── mod.rs
        └── test_counter.rs
```

<Callout emoji="🏃">
  If you're in a hurry, you can find the [final version](#test-cases-put-all-together) of the
  `test_counter.rs` file at the end of this chapter.
</Callout>

## Imports

```rust copy showLineNumbers{1} filename="test_counter.rs"
use cosmwasm_std::Empty;
use counter::msg::{CounterExecMsg, CounterInitMsg, CounterQueryMsg, CounterResponse};
use cw_multi_test::{App, Contract, ContractWrapper, Executor, IntoAddr};
```

## Wrapping the contact

```rust copy showLineNumbers{5} filename="test_counter.rs"
fn counter_contract() -> Box<dyn Contract<Empty>> {
    Box::new(ContractWrapper::new_with_empty(
        counter::contract::execute,
        counter::contract::instantiate,
        counter::contract::query,
    ))
}
```

(topics to cover)

- `Contract{:rust}`
- `ContractWrapper{:rust}`

## Testing counter initialization

### Testing initialization with zero

```rust copy showLineNumbers{13} filename="test_counter.rs"
#[test]
fn instantiating_with_zero_should_work() {
    let mut app = App::default();

    let code_id = app.store_code(counter_contract());

    let owner = "owner".into_addr();

    let contract_addr = app
        .instantiate_contract(
            code_id,
            owner,
            &CounterInitMsg::Zero,
            &[],
            "counter-label",
            None,
        )
        .unwrap();

    let res: CounterResponse = app
        .wrap()
        .query_wasm_smart(contract_addr, &CounterQueryMsg::Value)
        .unwrap();

    assert_eq!(0, res.value);
}
```

(topics to cover)

- `App::default{:rust}`
- `app.store_code{:rust}`
- `app.instantiate_contract{:rust}`
- `app.query_wasm_smart{:rust}`
- `IntoAddr{:rust}`
- `CounterInitMsg::Zero{:rust}`
- `CounterQueryMsg::Value{:rust}`

Let's run the first test:

```shell copy filename="TERMINAL"
cargo test
```

The expected output should look like the example shown below. Note that only the results of
integration tests are shown. For brevity, the results of unit tests and documentation tests are
omitted, as we are focusing only on integration tests in this example.

```ansi filename="OUTPUT"
     [32;1mRunning[0m tests/mod.rs (target/debug/deps/mod-319eb78408f3e46f)

running 1 test
test multitest::test_counter::instantiating_with_zero_should_work ... [32;1mok[0m

test result: [32;1mok[0m. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

Now, let's run all tests with [cargo-nextest]():

```shell copy filename="TERMINAL"
cargo nextest run
```

Similarly, one test passes:

```ansi filename="OUTPUT"
    [32;1mFinished[0m `test` profile [unoptimized + debuginfo] target(s) in 0.06s
    [32;1mStarting[0m 1 test across 2 binaries (run ID: bfc0013c-eb8e-447c-8027-a7c2b8c5cb80, nextest profile: default)
        [32;1mPASS[0m [   0.005s] [38;5;134;1mcounter::mod[0m [38;5;73;1mmultitest::test_counter::[0m[38;5;39;1minstantiating_with_zero_should_work[0m
------------
     [32;1mSummary[0m [   0.005s] 1 test run: 1 [32;1mpassed[0m, 0 skipped
```

<Callout type="info" emoji="☉">
  For brevity, in the upcoming test cases in this chapter, we will skip running tests using
  [cargo-nextest]. However, you can always run all tests by typing `cargo nextest run`.
</Callout>

Ok, let's check the code coverage after adding the first test case:

```shell copy filename="TERMINAL"
./coverage.sh
```

```ansi filename="OUTPUT"
|| Tested/Total Lines:
|| src/contract.rs: 10/18
||
55.56% coverage, 10/18 lines covered
```

Our first test case covered over 50% of the code in the **counter** smart contract. The detailed
code coverage report generated by Tarpaulin is attached below.

```ansi {21,28,34-38,41} showLineNumbers filename="Code coverage report (CosmWasm version)"
[0;30m #[cfg(not(feature = "library"))]
[0;30m use cosmwasm_std::entry_point;
[0;30m
[0;30m use crate::msg::{CounterExecMsg, CounterInitMsg, CounterQueryMsg, CounterResponse};
[0;30m use cosmwasm_std::{to_json_binary, Binary, Deps, DepsMut, Env, MessageInfo, Response, StdError};
[0;30m use cw_storage_plus::Item;
[0;30m
[0;30m const COUNTER: Item<u8> = Item::new("value");
[0;30m
[0;30m #[cfg_attr(not(feature = "library"), entry_point)]
[1;32m pub fn instantiate(
[0;30m     deps: DepsMut,
[0;30m     _env: Env,
[0;30m     _info: MessageInfo,
[0;30m     msg: CounterInitMsg,
[0;30m ) -> Result<Response, StdError> {
[1;32m     COUNTER.save(
[1;32m         deps.storage,
[1;32m         &match msg {
[1;32m             CounterInitMsg::Zero => 0,
[1;31m             CounterInitMsg::Set(new_value) => new_value,
[0;30m         },
[0;30m     )?;
[1;32m     Ok(Response::default())
[0;30m }
[0;30m
[0;30m #[cfg_attr(not(feature = "library"), entry_point)]
[1;31m pub fn execute(
[0;30m     deps: DepsMut,
[0;30m     _env: Env,
[0;30m     _info: MessageInfo,
[0;30m     msg: CounterExecMsg,
[0;30m ) -> Result<Response, StdError> {
[1;31m     COUNTER.update::<_, StdError>(deps.storage, |old_value| {
[1;31m         Ok(match msg {
[1;31m             CounterExecMsg::Inc => old_value.saturating_add(1),
[1;31m             CounterExecMsg::Dec => old_value.saturating_sub(1),
[1;31m             CounterExecMsg::Set(new_value) => new_value,
[0;30m         })
[0;30m     })?;
[1;31m     Ok(Response::default())
[0;30m }
[0;30m
[0;30m #[cfg_attr(not(feature = "library"), entry_point)]
[1;32m pub fn query(deps: Deps, _env: Env, msg: CounterQueryMsg) -> Result<Binary, StdError> {
[1;32m     match msg {
[1;32m         CounterQueryMsg::Value => Ok(to_json_binary(&CounterResponse {
[1;32m             value: COUNTER.may_load(deps.storage)?.unwrap(),
[0;30m         })?),
[0;30m     }
[0;30m }
```

(comment the coverage report)

### Testing initialization with a specific value

```rust copy showLineNumbers{40} filename="test_counter.rs"
#[test]
fn instantiating_with_value_should_work() {
    let mut app = App::default();

    let code_id = app.store_code(counter_contract());

    let owner = "owner".into_addr();

    let contract_addr = app
        .instantiate_contract(
            code_id,
            owner,
            &CounterInitMsg::Set(12),
            &[],
            "counter-label",
            None,
        )
        .unwrap();

    let res: CounterResponse = app
        .wrap()
        .query_wasm_smart(contract_addr, &CounterQueryMsg::Value)
        .unwrap();

    assert_eq!(12, res.value);
}
```

(topics to cover)

- `CounterInitMsg::Set{:rust}`

(rest was explained in the previous test cases)

```shell copy filename="TERMINAL"
cargo test
```

```ansi filename="OUTPUT"
     [32;1mRunning[0m tests/mod.rs (target/debug/deps/mod-319eb78408f3e46f)

running 2 tests
test multitest::test_counter::instantiating_with_zero_should_work ... [32;1mok[0m
test multitest::test_counter::instantiating_with_value_should_work ... [32;1mok[0m

test result: [32;1mok[0m. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

```shell copy filename="TERMINAL"
./coverage.sh
```

```ansi filename="OUTPUT"
|| Tested/Total Lines:
|| src/contract.rs: 11/18
||
61.11% coverage, 11/18 lines covered
```

```ansi {28,34-38,41} showLineNumbers filename="Code coverage report (CosmWasm version)"
[0;30m #[cfg(not(feature = "library"))]
[0;30m use cosmwasm_std::entry_point;
[0;30m
[0;30m use crate::msg::{CounterExecMsg, CounterInitMsg, CounterQueryMsg, CounterResponse};
[0;30m use cosmwasm_std::{to_json_binary, Binary, Deps, DepsMut, Env, MessageInfo, Response, StdError};
[0;30m use cw_storage_plus::Item;
[0;30m
[0;30m const COUNTER: Item<u8> = Item::new("value");
[0;30m
[0;30m #[cfg_attr(not(feature = "library"), entry_point)]
[1;32m pub fn instantiate(
[0;30m     deps: DepsMut,
[0;30m     _env: Env,
[0;30m     _info: MessageInfo,
[0;30m     msg: CounterInitMsg,
[0;30m ) -> Result<Response, StdError> {
[1;32m     COUNTER.save(
[1;32m         deps.storage,
[1;32m         &match msg {
[1;32m             CounterInitMsg::Zero => 0,
[1;32m             CounterInitMsg::Set(new_value) => new_value,
[0;30m         },
[0;30m     )?;
[1;32m     Ok(Response::default())
[0;30m }
[0;30m
[0;30m #[cfg_attr(not(feature = "library"), entry_point)]
[1;31m pub fn execute(
[0;30m     deps: DepsMut,
[0;30m     _env: Env,
[0;30m     _info: MessageInfo,
[0;30m     msg: CounterExecMsg,
[0;30m ) -> Result<Response, StdError> {
[1;31m     COUNTER.update::<_, StdError>(deps.storage, |old_value| {
[1;31m         Ok(match msg {
[1;31m             CounterExecMsg::Inc => old_value.saturating_add(1),
[1;31m             CounterExecMsg::Dec => old_value.saturating_sub(1),
[1;31m             CounterExecMsg::Set(new_value) => new_value,
[0;30m         })
[0;30m     })?;
[1;31m     Ok(Response::default())
[0;30m }
[0;30m
[0;30m #[cfg_attr(not(feature = "library"), entry_point)]
[1;32m pub fn query(deps: Deps, _env: Env, msg: CounterQueryMsg) -> Result<Binary, StdError> {
[1;32m     match msg {
[1;32m         CounterQueryMsg::Value => Ok(to_json_binary(&CounterResponse {
[1;32m             value: COUNTER.may_load(deps.storage)?.unwrap(),
[0;30m         })?),
[0;30m     }
[0;30m }
```

(comment the coverage report)

## Testing counter increment

### Testing increment by 1

```rust copy showLineNumbers{67} filename="test_counter.rs"
#[test]
fn incrementing_should_work() {
    let mut app = App::default();

    let code_id = app.store_code(counter_contract());

    let owner = "owner".into_addr();

    let contract_addr = app
        .instantiate_contract(
            code_id,
            owner.clone(),
            &CounterInitMsg::Zero,
            &[],
            "counter-contract",
            None,
        )
        .unwrap();

    app.execute_contract(owner, contract_addr.clone(), &CounterActionMsg::Inc, &[])
        .unwrap();

    let res: CounterResponse = app
        .wrap()
        .query_wasm_smart(contract_addr, &CounterQuery::Value)
        .unwrap();

    assert_eq!(1, res.value);
}
```

(topics to cover)

- `app.execute_contract{:rust}`
- `CounterActionMsg::Inc{:rust}`

(rest was explained in the previous test cases)

```shell copy filename="TERMINAL"
cargo test
```

```ansi filename="OUTPUT"
     [32;1mRunning[0m tests/mod.rs (target/debug/deps/mod-319eb78408f3e46f)

running 3 tests
test multitest::test_counter::instantiating_with_zero_should_work ... [32;1mok[0m
test multitest::test_counter::instantiating_with_value_should_work ... [32;1mok[0m
test multitest::test_counter::incrementing_should_work ... [32;1mok[0m

test result: [32;1mok[0m. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

```shell copy copy filename="TERMINAL"
./coverage.sh
```

```ansi filename="OUTPUT"
|| Tested/Total Lines:
|| src/contract.rs: 16/18
||
88.89% coverage, 16/18 lines covered
```

```ansi {37-38} showLineNumbers filename="Code coverage report (CosmWasm version)"
[0;30m #[cfg(not(feature = "library"))]
[0;30m use cosmwasm_std::entry_point;
[0;30m
[0;30m use crate::msg::{CounterExecMsg, CounterInitMsg, CounterQueryMsg, CounterResponse};
[0;30m use cosmwasm_std::{to_json_binary, Binary, Deps, DepsMut, Env, MessageInfo, Response, StdError};
[0;30m use cw_storage_plus::Item;
[0;30m
[0;30m const COUNTER: Item<u8> = Item::new("value");
[0;30m
[0;30m #[cfg_attr(not(feature = "library"), entry_point)]
[1;32m pub fn instantiate(
[0;30m     deps: DepsMut,
[0;30m     _env: Env,
[0;30m     _info: MessageInfo,
[0;30m     msg: CounterInitMsg,
[0;30m ) -> Result<Response, StdError> {
[1;32m     COUNTER.save(
[1;32m         deps.storage,
[1;32m         &match msg {
[1;32m             CounterInitMsg::Zero => 0,
[1;32m             CounterInitMsg::Set(new_value) => new_value,
[0;30m         },
[0;30m     )?;
[1;32m     Ok(Response::default())
[0;30m }
[0;30m
[0;30m #[cfg_attr(not(feature = "library"), entry_point)]
[1;32m pub fn execute(
[0;30m     deps: DepsMut,
[0;30m     _env: Env,
[0;30m     _info: MessageInfo,
[0;30m     msg: CounterExecMsg,
[0;30m ) -> Result<Response, StdError> {
[1;32m     COUNTER.update::<_, StdError>(deps.storage, |old_value| {
[1;32m         Ok(match msg {
[1;32m             CounterExecMsg::Inc => old_value.saturating_add(1),
[1;31m             CounterExecMsg::Dec => old_value.saturating_sub(1),
[1;31m             CounterExecMsg::Set(new_value) => new_value,
[0;30m         })
[0;30m     })?;
[1;32m     Ok(Response::default())
[0;30m }
[0;30m
[0;30m #[cfg_attr(not(feature = "library"), entry_point)]
[1;32m pub fn query(deps: Deps, _env: Env, msg: CounterQueryMsg) -> Result<Binary, StdError> {
[1;32m     match msg {
[1;32m         CounterQueryMsg::Value => Ok(to_json_binary(&CounterResponse {
[1;32m             value: COUNTER.may_load(deps.storage)?.unwrap(),
[0;30m         })?),
[0;30m     }
[0;30m }
```

(comment the coverage report)

### Testing increment overflow

```rust copy showLineNumbers{97} filename="test_counter.rs"
#[test]
fn incrementing_should_stop_at_maximum() {
    let mut app = App::default();

    let code_id = app.store_code(counter_contract());

    let owner = "owner".into_addr();

    let contract_addr = app
        .instantiate_contract(
            code_id,
            owner.clone(),
            &CounterInitMsg::Set(250),
            &[],
            "counter",
            None,
        )
        .unwrap();

    for _ in 1..=10 {
        app.execute_contract(
            owner.clone(),
            contract_addr.clone(),
            &CounterExecMsg::Inc,
            &[],
        )
        .unwrap();
    }

    let res: CounterResponse = app
        .wrap()
        .query_wasm_smart(contract_addr, &CounterQueryMsg::Value)
        .unwrap();

    assert_eq!(255, res.value);
}
```

(topics to cover)

- initialization with 250
- multiple call of `execute` endpoint
- how the overflowing was handled in the smart contract

(rest was explained in the previous test cases)

```shell copy filename="TERMINAL"
cargo test
```

```ansi filename="OUTPUT"
     [32;1mRunning[0m tests/mod.rs (target/debug/deps/mod-319eb78408f3e46f)

running 4 tests
test multitest::test_counter::instantiating_with_zero_should_work ... [32;1mok[0m
test multitest::test_counter::instantiating_with_value_should_work ... [32;1mok[0m
test multitest::test_counter::incrementing_should_work ... [32;1mok[0m
test multitest::test_counter::incrementing_should_stop_at_maximum ... [32;1mok[0m

test result: [32;1mok[0m. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

```shell copy filename="TERMINAL"
./coverage.sh
```

```ansi filename="OUTPUT"
|| Tested/Total Lines:
|| src/contract.rs: 16/18
||
88.89% coverage, 16/18 lines covered
```

The code coverage did not change after adding this test case, but a very important use case was
tested: handling overflow during counter incrementation.

## Testing counter decrement

### Testing decrement by 1

```rust copy showLineNumbers{134} filename="test_counter.rs"
#[test]
fn decrementing_should_work() {
    let mut app = App::default();

    let code_id = app.store_code(counter_contract());

    let owner = "owner".into_addr();

    let contract_addr = app
        .instantiate_contract(
            code_id,
            owner.clone(),
            &CounterInitMsg::Set(126),
            &[],
            "counter-label",
            None,
        )
        .unwrap();

    app.execute_contract(owner, contract_addr.clone(), &CounterExecMsg::Dec, &[])
        .unwrap();

    let res: CounterResponse = app
        .wrap()
        .query_wasm_smart(contract_addr, &CounterQueryMsg::Value)
        .unwrap();

    assert_eq!(125, res.value);
}
```

(topics to cover)

- initialization with 126
- `CounterExecMsg::Dec{:rust}`

(rest was explained in the previous test cases)

```shell copy filename="TERMINAL"
cargo test
```

```ansi filename="OUTPUT"
     [32;1mRunning[0m tests/mod.rs (target/debug/deps/mod-319eb78408f3e46f)

running 5 tests
test multitest::test_counter::instantiating_with_zero_should_work ... [32;1mok[0m
test multitest::test_counter::instantiating_with_value_should_work ... [32;1mok[0m
test multitest::test_counter::incrementing_should_work ... [32;1mok[0m
test multitest::test_counter::incrementing_should_stop_at_maximum ... [32;1mok[0m
test multitest::test_counter::decrementing_should_work ... [32;1mok[0m

test result: [32;1mok[0m. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

```shell copy filename="TERMINAL"
./coverage.sh
```

```ansi filename="OUTPUT"
|| Tested/Total Lines:
|| src/contract.rs: 17/18
||
94.44% coverage, 17/18 lines covered
```

```ansi {38} showLineNumbers filename="Code coverage report (CosmWasm version)"
[0;30m #[cfg(not(feature = "library"))]
[0;30m use cosmwasm_std::entry_point;
[0;30m
[0;30m use crate::msg::{CounterExecMsg, CounterInitMsg, CounterQueryMsg, CounterResponse};
[0;30m use cosmwasm_std::{to_json_binary, Binary, Deps, DepsMut, Env, MessageInfo, Response, StdError};
[0;30m use cw_storage_plus::Item;
[0;30m
[0;30m const COUNTER: Item<u8> = Item::new("value");
[0;30m
[0;30m #[cfg_attr(not(feature = "library"), entry_point)]
[1;32m pub fn instantiate(
[0;30m     deps: DepsMut,
[0;30m     _env: Env,
[0;30m     _info: MessageInfo,
[0;30m     msg: CounterInitMsg,
[0;30m ) -> Result<Response, StdError> {
[1;32m     COUNTER.save(
[1;32m         deps.storage,
[1;32m         &match msg {
[1;32m             CounterInitMsg::Zero => 0,
[1;32m             CounterInitMsg::Set(new_value) => new_value,
[0;30m         },
[0;30m     )?;
[1;32m     Ok(Response::default())
[0;30m }
[0;30m
[0;30m #[cfg_attr(not(feature = "library"), entry_point)]
[1;32m pub fn execute(
[0;30m     deps: DepsMut,
[0;30m     _env: Env,
[0;30m     _info: MessageInfo,
[0;30m     msg: CounterExecMsg,
[0;30m ) -> Result<Response, StdError> {
[1;32m     COUNTER.update::<_, StdError>(deps.storage, |old_value| {
[1;32m         Ok(match msg {
[1;32m             CounterExecMsg::Inc => old_value.saturating_add(1),
[1;32m             CounterExecMsg::Dec => old_value.saturating_sub(1),
[1;31m             CounterExecMsg::Set(new_value) => new_value,
[0;30m         })
[0;30m     })?;
[1;32m     Ok(Response::default())
[0;30m }
[0;30m
[0;30m #[cfg_attr(not(feature = "library"), entry_point)]
[1;32m pub fn query(deps: Deps, _env: Env, msg: CounterQueryMsg) -> Result<Binary, StdError> {
[1;32m     match msg {
[1;32m         CounterQueryMsg::Value => Ok(to_json_binary(&CounterResponse {
[1;32m             value: COUNTER.may_load(deps.storage)?.unwrap(),
[0;30m         })?),
[0;30m     }
[0;30m }
```

(comment the coverage report)

### Testing decrement underflow

```rust copy showLineNumbers{164} filename="test_counter.rs"
#[test]
fn decrementing_should_stop_at_minimum() {
    let mut app = App::default();

    let code_id = app.store_code(counter_contract());

    let owner = "owner".into_addr();

    let contract_addr = app
        .instantiate_contract(
            code_id,
            owner.clone(),
            &CounterInitMsg::Set(5),
            &[],
            "counter-label",
            None,
        )
        .unwrap();

    for _ in 1..=10 {
        app.execute_contract(
            owner.clone(),
            contract_addr.clone(),
            &CounterExecMsg::Dec,
            &[],
        )
        .unwrap();
    }

    let res: CounterResponse = app
        .wrap()
        .query_wasm_smart(contract_addr, &CounterQueryMsg::Value)
        .unwrap();

    assert_eq!(0, res.value);
}
```

(topics to cover)

- initialization with 5
- multiple decrementation
- handling underflow in the contract

(rest was explained in the previous test cases)

```shell copy filename="TERMINAL"
cargo test
```

```ansi filename="OUTPUT"
     [32;1mRunning[0m tests/mod.rs (target/debug/deps/mod-319eb78408f3e46f)

running 6 tests
test multitest::test_counter::instantiating_with_zero_should_work ... [32;1mok[0m
test multitest::test_counter::instantiating_with_value_should_work ... [32;1mok[0m
test multitest::test_counter::incrementing_should_work ... [32;1mok[0m
test multitest::test_counter::incrementing_should_stop_at_maximum ... [32;1mok[0m
test multitest::test_counter::decrementing_should_work ... [32;1mok[0m
test multitest::test_counter::decrementing_should_stop_at_minimum ... [32;1mok[0m

test result: [32;1mok[0m. 6 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

```shell copy filename="TERMINAL"
./coverage.sh
```

```ansi filename="OUTPUT"
|| Tested/Total Lines:
|| src/contract.rs: 17/18
||
94.44% coverage, 17/18 lines covered
```

The code coverage did not change after adding this test case, but a very important use case was
tested: handling underflow during counter decrementation.

## Testing counter value changes

```rust copy showLineNumbers{201} filename="test_counter.rs"
#[test]
fn setting_value_should_work() {
    let mut app = App::default();

    let code_id = app.store_code(counter_contract());

    let owner = "owner".into_addr();

    let contract_addr = app
        .instantiate_contract(
            code_id,
            owner.clone(),
            &CounterInitMsg::Set(5),
            &[],
            "counter-label",
            None,
        )
        .unwrap();

    app.execute_contract(owner, contract_addr.clone(), &CounterExecMsg::Set(126), &[])
        .unwrap();

    let res: CounterResponse = app
        .wrap()
        .query_wasm_smart(contract_addr, &CounterQueryMsg::Value)
        .unwrap();

    assert_eq!(126, res.value);
}
```

(topics to cover)

- `CounterInitMsg::Set{:rust}`

(rest was explained in the previous test cases)

```shell copy filename="TERMINAL"
cargo test
```

```ansi filename="OUTPUT"
     [32;1mRunning[0m tests/mod.rs (target/debug/deps/mod-319eb78408f3e46f)

running 7 tests
test multitest::test_counter::instantiating_with_zero_should_work ... [32;1mok[0m
test multitest::test_counter::instantiating_with_value_should_work ... [32;1mok[0m
test multitest::test_counter::incrementing_should_work ... [32;1mok[0m
test multitest::test_counter::incrementing_should_stop_at_maximum ... [32;1mok[0m
test multitest::test_counter::decrementing_should_work ... [32;1mok[0m
test multitest::test_counter::decrementing_should_stop_at_minimum ... [32;1mok[0m
test multitest::test_counter::setting_value_should_work ... [32;1mok[0m

test result: [32;1mok[0m. 7 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

```shell copy filename="TERMINAL"
./coverage.sh
```

```ansi filename="OUTPUT"
|| Tested/Total Lines:
|| src/contract.rs: 18/18
||
100.00% coverage, 18/18 lines covered
```

Nice, you have reached 💯% code coverage.

```ansi showLineNumbers filename="Code coverage report (CosmWasm version)"
[0;30m #[cfg(not(feature = "library"))]
[0;30m use cosmwasm_std::entry_point;
[0;30m
[0;30m use crate::msg::{CounterExecMsg, CounterInitMsg, CounterQueryMsg, CounterResponse};
[0;30m use cosmwasm_std::{to_json_binary, Binary, Deps, DepsMut, Env, MessageInfo, Response, StdError};
[0;30m use cw_storage_plus::Item;
[0;30m
[0;30m const COUNTER: Item<u8> = Item::new("value");
[0;30m
[0;30m #[cfg_attr(not(feature = "library"), entry_point)]
[1;32m pub fn instantiate(
[0;30m     deps: DepsMut,
[0;30m     _env: Env,
[0;30m     _info: MessageInfo,
[0;30m     msg: CounterInitMsg,
[0;30m ) -> Result<Response, StdError> {
[1;32m     COUNTER.save(
[1;32m         deps.storage,
[1;32m         &match msg {
[1;32m             CounterInitMsg::Zero => 0,
[1;32m             CounterInitMsg::Set(new_value) => new_value,
[0;30m         },
[0;30m     )?;
[1;32m     Ok(Response::default())
[0;30m }
[0;30m
[0;30m #[cfg_attr(not(feature = "library"), entry_point)]
[1;32m pub fn execute(
[0;30m     deps: DepsMut,
[0;30m     _env: Env,
[0;30m     _info: MessageInfo,
[0;30m     msg: CounterExecMsg,
[0;30m ) -> Result<Response, StdError> {
[1;32m     COUNTER.update::<_, StdError>(deps.storage, |old_value| {
[1;32m         Ok(match msg {
[1;32m             CounterExecMsg::Inc => old_value.saturating_add(1),
[1;32m             CounterExecMsg::Dec => old_value.saturating_sub(1),
[1;32m             CounterExecMsg::Set(new_value) => new_value,
[0;30m         })
[0;30m     })?;
[1;32m     Ok(Response::default())
[0;30m }
[0;30m
[0;30m #[cfg_attr(not(feature = "library"), entry_point)]
[1;32m pub fn query(deps: Deps, _env: Env, msg: CounterQueryMsg) -> Result<Binary, StdError> {
[1;32m     match msg {
[1;32m         CounterQueryMsg::Value => Ok(to_json_binary(&CounterResponse {
[1;32m             value: COUNTER.may_load(deps.storage)?.unwrap(),
[0;30m         })?),
[0;30m     }
[0;30m }
```

All functionalities of the **counter** smart contract has been tested.

## Test cases put all together

Below is the final version of the `test_counter.rs` file, containing all previously presented test
cases for the **counter** smart contract written using pure CosmWasm libraries.

```rust copy showLineNumbers filename="test_counter.rs"
use cosmwasm_std::Empty;
use counter::msg::{CounterExecMsg, CounterInitMsg, CounterQueryMsg, CounterResponse};
use cw_multi_test::{App, Contract, ContractWrapper, Executor, IntoAddr};

fn counter_contract() -> Box<dyn Contract<Empty>> {
    Box::new(ContractWrapper::new_with_empty(
        counter::contract::execute,
        counter::contract::instantiate,
        counter::contract::query,
    ))
}

#[test]
fn instantiating_with_zero_should_work() {
    let mut app = App::default();

    let code_id = app.store_code(counter_contract());

    let owner = "owner".into_addr();

    let contract_addr = app
        .instantiate_contract(
            code_id,
            owner,
            &CounterInitMsg::Zero,
            &[],
            "counter-label",
            None,
        )
        .unwrap();

    let res: CounterResponse = app
        .wrap()
        .query_wasm_smart(contract_addr, &CounterQueryMsg::Value)
        .unwrap();

    assert_eq!(0, res.value);
}

#[test]
fn instantiating_with_value_should_work() {
    let mut app = App::default();

    let code_id = app.store_code(counter_contract());

    let owner = "owner".into_addr();

    let contract_addr = app
        .instantiate_contract(
            code_id,
            owner,
            &CounterInitMsg::Set(12),
            &[],
            "counter-label",
            None,
        )
        .unwrap();

    let res: CounterResponse = app
        .wrap()
        .query_wasm_smart(contract_addr, &CounterQueryMsg::Value)
        .unwrap();

    assert_eq!(12, res.value);
}

#[test]
fn incrementing_should_work() {
    let mut app = App::default();

    let code_id = app.store_code(counter_contract());

    let owner = "owner".into_addr();

    let contract_addr = app
        .instantiate_contract(
            code_id,
            owner.clone(),
            &CounterInitMsg::Zero,
            &[],
            "counter-contract",
            None,
        )
        .unwrap();

    app.execute_contract(owner, contract_addr.clone(), &CounterExecMsg::Inc, &[])
        .unwrap();

    let res: CounterResponse = app
        .wrap()
        .query_wasm_smart(contract_addr, &CounterQueryMsg::Value)
        .unwrap();

    assert_eq!(1, res.value);
}

#[test]
fn incrementing_should_stop_at_maximum() {
    let mut app = App::default();

    let code_id = app.store_code(counter_contract());

    let owner = "owner".into_addr();

    let contract_addr = app
        .instantiate_contract(
            code_id,
            owner.clone(),
            &CounterInitMsg::Set(250),
            &[],
            "counter",
            None,
        )
        .unwrap();

    for _ in 1..=10 {
        app.execute_contract(
            owner.clone(),
            contract_addr.clone(),
            &CounterExecMsg::Inc,
            &[],
        )
        .unwrap();
    }

    let res: CounterResponse = app
        .wrap()
        .query_wasm_smart(contract_addr, &CounterQueryMsg::Value)
        .unwrap();

    assert_eq!(255, res.value);
}

#[test]
fn decrementing_should_work() {
    let mut app = App::default();

    let code_id = app.store_code(counter_contract());

    let owner = "owner".into_addr();

    let contract_addr = app
        .instantiate_contract(
            code_id,
            owner.clone(),
            &CounterInitMsg::Set(126),
            &[],
            "counter-label",
            None,
        )
        .unwrap();

    app.execute_contract(owner, contract_addr.clone(), &CounterExecMsg::Dec, &[])
        .unwrap();

    let res: CounterResponse = app
        .wrap()
        .query_wasm_smart(contract_addr, &CounterQueryMsg::Value)
        .unwrap();

    assert_eq!(125, res.value);
}

#[test]
fn decrementing_should_stop_at_minimum() {
    let mut app = App::default();

    let code_id = app.store_code(counter_contract());

    let owner = "owner".into_addr();

    let contract_addr = app
        .instantiate_contract(
            code_id,
            owner.clone(),
            &CounterInitMsg::Set(5),
            &[],
            "counter-label",
            None,
        )
        .unwrap();

    for _ in 1..=10 {
        app.execute_contract(
            owner.clone(),
            contract_addr.clone(),
            &CounterExecMsg::Dec,
            &[],
        )
        .unwrap();
    }

    let res: CounterResponse = app
        .wrap()
        .query_wasm_smart(contract_addr, &CounterQueryMsg::Value)
        .unwrap();

    assert_eq!(0, res.value);
}

#[test]
fn setting_value_should_work() {
    let mut app = App::default();

    let code_id = app.store_code(counter_contract());

    let owner = "owner".into_addr();

    let contract_addr = app
        .instantiate_contract(
            code_id,
            owner.clone(),
            &CounterInitMsg::Set(5),
            &[],
            "counter-label",
            None,
        )
        .unwrap();

    app.execute_contract(owner, contract_addr.clone(), &CounterExecMsg::Set(126), &[])
        .unwrap();

    let res: CounterResponse = app
        .wrap()
        .query_wasm_smart(contract_addr, &CounterQueryMsg::Value)
        .unwrap();

    assert_eq!(126, res.value);
}
```

## Summary

(write some nice summary)

<Cards>
  <Card
    title="Writing tests for counter smart contract written using the Sylvia framework"
    href="writing-tests-sylvia"
    icon=""
    children=""
  />
</Cards>
