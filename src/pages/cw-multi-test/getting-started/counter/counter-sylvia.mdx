---
tags: ["multitest", "getting started", "counter", "Sylvia"]
---

import { Callout, Card, Cards } from "nextra/components";

# Counter written in Sylvia

## Counter source code

The following code snippets present the content of [**Cargo.toml**](#cargotoml),
[**lib.rs**](#librs), [**msg.rs**](#msgrs), and [**contract.rs**](#contractrs) files, respectively.
YouÂ can just copy and paste the provided content to previously created empty files, temporarily
skipping the detailed explanations. However, if you're curious about what happens inside each file,
feel free to check the detailed explanations provided for each code snippet.

---

### `Cargo.toml`

```toml filename="Cargo.toml" copy
[package]
name = "counter"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib", "rlib"]

[features]
# use library feature to disable all instantiate/execute/query exports
library = []

[dependencies]
cosmwasm-schema = "2"
cosmwasm-std = { version = "2" }
cw-storage-plus = "2"
schemars = "0.8"
serde = "1.0"
sylvia = { version = "1", features = ["mt"] }

[dev-dependencies]
cw-multi-test = { version = "2", features = ["cosmwasm_2_0"] }
```

---

### `lib.rs`

```rust filename="lib.rs" copy
pub mod contract;
pub mod msg;
```

---

### `msg.rs`

```rust filename="msg.rs" copy
use cosmwasm_schema::cw_serde;

#[cw_serde]
pub enum CounterInitMsg {
    Zero,
    Set(u8),
}

#[cw_serde]
pub struct CounterResponse {
    pub count: u8,
}
```

---

### `contract.rs`

```rust filename="contract.rs" copy
use crate::msg::{CounterInitMsg, CounterResponse};
use cosmwasm_std::{Response, StdResult};
use cw_storage_plus::Item;
use sylvia::contract;
use sylvia::types::{ExecCtx, InstantiateCtx, QueryCtx};

pub struct CounterContract {
    pub count: Item<u8>,
}

#[cfg_attr(not(feature = "library"), sylvia::entry_points)]
#[contract]
impl CounterContract {
    pub const fn new() -> Self {
        Self {
            count: Item::new("count"),
        }
    }

    #[sv::msg(instantiate)]
    fn zero(&self, ctx: InstantiateCtx, msg: CounterInitMsg) -> StdResult<Response> {
        match msg {
            CounterInitMsg::Zero => self.count.save(ctx.deps.storage, &0)?,
            CounterInitMsg::Set(value) => self.count.save(ctx.deps.storage, &value)?,
        }
        Ok(Response::new())
    }

    #[sv::msg(exec)]
    fn inc(&self, ctx: ExecCtx) -> StdResult<Response> {
        self.count
            .update(ctx.deps.storage, |count| -> StdResult<u8> {
                Ok(count.saturating_add(1))
            })?;
        Ok(Response::new())
    }

    #[sv::msg(exec)]
    fn dec(&self, ctx: ExecCtx) -> StdResult<Response> {
        self.count
            .update(ctx.deps.storage, |count| -> StdResult<u8> {
                Ok(count.saturating_sub(1))
            })?;
        Ok(Response::new())
    }

    #[sv::msg(exec)]
    fn set(&self, ctx: ExecCtx, value: u8) -> StdResult<Response> {
        self.count.save(ctx.deps.storage, &value)?;
        Ok(Response::new())
    }

    #[sv::msg(query)]
    fn count(&self, ctx: QueryCtx) -> StdResult<CounterResponse> {
        let count = self.count.load(ctx.deps.storage)?;
        Ok(CounterResponse { count })
    }
}
```

---

## What next?

Having the **counter** smart contract prepared, you can begin writing tests using **`MultiTest`**,
or you might want to check the pure CosmWasm version of the **counter** smart contract first.

<Cards>
  <Card title="Writing tests" href="../writing-tests" icon="" children="" />
  <Card
    title="Counter written using pure CosmWasm library"
    href="counter-cosmwasm"
    icon=""
    children=""
  />
</Cards>
