---
tags: ["multitest", "getting started", "tests", "CosmWasm"]
---

import { Callout, Card, Cards, Steps } from "nextra/components";

[cargo-nextest]: https://nexte.st

# Writing tests in Sylvia

As a reminder, the file structure of the **counter** project written in Sylvia is shown below. In
this chapter, you will be writing tests for this smart contract. All tests will be placed in a file
named `test_counter.rs`, highlighted in **line 12**.

```ansi {12} showLineNumbers filename="counter (directory)"
[34;1m.[0m
â”œâ”€â”€Â Cargo.toml
â”œâ”€â”€Â [32;1mcoverage.sh[0m
â”œâ”€â”€Â [34;1msrc[0m
â”‚Â Â Â â”œâ”€â”€ contract.rs
â”‚Â Â Â â”œâ”€â”€ lib.rs
â”‚Â Â Â â””â”€â”€ msg.rs
â””â”€â”€Â [34;1mtests[0m
Â Â Â Â â”œâ”€â”€Â mod.rs
Â Â Â Â â””â”€â”€Â [34;1mmultitest[0m
Â Â Â Â Â Â Â Â â”œâ”€â”€Â mod.rs
Â Â Â Â Â Â Â Â â””â”€â”€Â test_counter.rs
```

<Callout emoji="ðŸƒ">
  If you're in a hurry, you can find the [final version](#test-cases-put-all-together) of the
  `test_counter.rs` file at the end of this chapter.
</Callout>

## Imports

At the very beginning of the `test_counter.rs` file, the necessary imports for implementing all test
cases are included:

- structures generated by Sylvia (`CodeId{:rust}`, `CounterContractProxy{:rust}`),
- initialization message for the contract (`CounterInitMsg{:rust}`),
- a trait for converting a string into address (`IntoAddr{:rust}`),
- and the Sylvia app (chain) struct that simulates the real-life blockchain
  (`sylvia::multitest::App{:rust}`).

Just copy and paste the code presented below to your `test_counter.rs` file:

```rust copy showLineNumbers filename="test_counter.rs"
use counter::contract::sv::mt::{CodeId, CounterContractProxy};
use counter::msg::CounterInitMsg;
use sylvia::cw_multi_test::IntoAddr;
use sylvia::multitest::App;
```

## Testing counter initialization

There are two ways to initialize the **counter** contact:

- with zero value,
- with specific value in range \[0..255\].

### Testing initialization with zero

This first test verifies that the counter contract can be instantiated with an initial value of zero
using the `CounterInitMsg::Zero{:rust}` message. It ensures that the contract correctly stores the
initial value of zero, and that the query mechanism returns the expected counter value.

It is an example of a well-structured test case with clear setup, execution, and validation steps.

```rust copy showLineNumbers{6} filename="test_counter.rs"
#[test]
fn instantiating_with_zero_should_work() {
    let app = App::default();

    let code_id = CodeId::store_code(&app);

    let owner = "owner".into_addr();

    let contract = code_id
        .instantiate(CounterInitMsg::Zero)
        .call(&owner)
        .unwrap();

    assert_eq!(0, contract.value().unwrap().value);
}
```

Let's take a closer look at this test's flow.

<Steps>
#### Chain initialization

Creating an instance of the `App{:rust}` simulates starting a blockchain. There are multiple ways to
instantiate the `App{:rust}`, but the simplest way, shown below, uses the `default{:rust}` function.

```rust showLineNumbers{8} filename="test_counter.rs"
let app = App::default();
```

#### Storing contract on chain

The next step is to store the contract's code on the chain. The `CodeId{:rust}` struct generated by
Sylvia for the **counter** contract provides a `store_code{:rust}` function for this purpose.
`store_code{:rust}` returns a handle to the contract assigned to `code_id{:rust}`. This
`code_id{:rust}` is used to reference the stored contract later in test.

```rust showLineNumbers{10} filename="test_counter.rs"
let code_id = CodeId::store_code(&app);
```

#### Defining the contract owner

Every instance of the contract has an owner represented as an address. In this test the string
`"owner"{:rust}` is converted to Bech32 address recognized by the blockchain.

```rust showLineNumbers{12} filename="test_counter.rs"
let owner = "owner".into_addr();
```

#### Contract instantiation

The contract is to be instantiated using `instantiate{:rust}` function provided by `code_id{:rust}`
with the initialization message variant `CounterInitMsg::Zero{:rust}`. `instantiate{:rust}` function
returns an instantiate proxy generated by Sylvia, which in turn provides a function `call{:rust}`
that triggers the instantiation of the contract. The `call{:rust}` function gets a single argument
being the address of the owner of the contract instance.

The `unwrap(){:rust}` function is used to handle the result of instantiating the contract, ensuring
the test fails if an error occurs. `call{:rust}` function returns a proxy to contract instance, used
later in this test.

```rust showLineNumbers{14} filename="test_counter.rs"
let contract = code_id
    .instantiate(CounterInitMsg::Zero)
    .call(&owner)
    .unwrap();
```

#### Querying the contract

After the contract is instantiated, this test queries the contract instance using the
`value(){:rust}` function which is a query entry-point generated by Sylvia for **counter** contract.
Using Sylvia framework, querying a contract is as simple as calling a function on the contract
instance. The result from the `value(){:rust}` function is simply unwrapped and resolves to
`CounterResponse{:rust}` which in turn holds the current value of the counter in the public field
named `value`.

```rust showLineNumbers{19} filename="test_counter.rs" /contract.value()/
assert_eq!(0, contract.value().unwrap().value);
```

#### Asserting the value

The final step is to assert that the value returned by the contract is `0{:rust}`. If the value were
non-zero, the test would fail.

```rust showLineNumbers{19} filename="test_counter.rs" /assert_eq!(0/
assert_eq!(0, contract.value().unwrap().value);
```

</Steps>

#### Running tests

Having the first test ready, let's run it:

```shell copy filename="TERMINAL"
cargo test
```

The expected output should look like the example shown below. Note that only the results of
integration tests are shown. For brevity, the results of unit tests and documentation tests are
omitted, as we are focusing only on integration tests in this example.

```ansi filename="OUTPUT"
     [32;1mRunning[0m tests/mod.rs (target/debug/deps/mod-a819a838d5b2d67d)

running 1 test
test multitest::test_counter::instantiating_with_zero_should_work ... [32;1mok[0m

test result: [32;1mok[0m. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

Now, let's run all tests using [cargo-nextest]:

```shell copy filename="TERMINAL"
cargo nextest run
```

Similarly, one test passes:

```ansi filename="OUTPUT"
    [32;1mFinished[0m `test` profile [unoptimized + debuginfo] target(s) in 27.67s
    [32;1mStarting[0m 1 test across 2 binaries (run ID: b2a72818-8d25-4194-9333-3af93c360132, nextest profile: default)
        [32;1mPASS[0m [   0.004s] [38;5;134;1mcounter::mod[0m [38;5;73;1mmultitest::test_counter::[0m[38;5;39;1minstantiating_with_zero_should_work[0m
------------
     [32;1mSummary[0m [   0.004s] 1 test run: 1 [32;1mpassed[0m, 0 skipped
```

<Callout type="info" emoji="â˜‰">
  For brevity, in the upcoming test cases in this chapter, we will skip running tests using
  [cargo-nextest]. However, you can always run all tests by typing `cargo nextest run`.
</Callout>

#### Code coverage

Let's check the code coverage after adding the first test:

```shell copy filename="TERMINAL"
./coverage.sh
```

```ansi filename="OUTPUT"
|| Tested/Total Lines:
|| src/contract.rs: 8/22
||
36.36% coverage, 8/22 lines covered
```

First test covered almost 40% of the code in the **counter** smart contract. The detailed code
coverage report (similar to the one generated by Tarpaulin) is shown below.

```ansi {24,30-33,35,39-42,44,48-50} showLineNumbers filename="CODE COVERAGE REPORT (Sylvia version)"
[0;30m use crate::msg::{CounterInitMsg, CounterResponse};
[0;30m use cosmwasm_std::{Response, StdResult};
[0;30m use cw_storage_plus::Item;
[0;30m use sylvia::contract;
[0;30m use sylvia::types::{ExecCtx, InstantiateCtx, QueryCtx};
[0;30m
[0;30m pub struct CounterContract {
[0;30m     pub count: Item<u8>,
[0;30m }
[0;30m
[0;30m #[cfg_attr(not(feature = "library"), sylvia::entry_points)]
[0;30m #[contract]
[0;30m impl CounterContract {
[1;32m     pub const fn new() -> Self {
[0;30m         Self {
[1;32m             count: Item::new("count"),
[0;30m         }
[0;30m     }
[0;30m
[0;30m     #[sv::msg(instantiate)]
[1;32m     fn init(&self, ctx: InstantiateCtx, msg: CounterInitMsg) -> StdResult<Response> {
[1;32m         match msg {
[1;32m             CounterInitMsg::Zero => self.count.save(ctx.deps.storage, &0)?,
[1;31m             CounterInitMsg::Set(value) => self.count.save(ctx.deps.storage, &value)?,
[0;30m         }
[1;32m         Ok(Response::new())
[0;30m     }
[0;30m
[0;30m     #[sv::msg(exec)]
[1;31m     fn inc(&self, ctx: ExecCtx) -> StdResult<Response> {
[1;31m         self.count
[1;31m             .update(ctx.deps.storage, |count| -> StdResult<u8> {
[1;31m                 Ok(count.saturating_add(1))
[0;30m             })?;
[1;31m         Ok(Response::new())
[0;30m     }
[0;30m
[0;30m     #[sv::msg(exec)]
[1;31m     fn dec(&self, ctx: ExecCtx) -> StdResult<Response> {
[1;31m         self.count
[1;31m             .update(ctx.deps.storage, |count| -> StdResult<u8> {
[1;31m                 Ok(count.saturating_sub(1))
[0;30m             })?;
[1;31m         Ok(Response::new())
[0;30m     }
[0;30m
[0;30m     #[sv::msg(exec)]
[1;31m     fn set(&self, ctx: ExecCtx, value: u8) -> StdResult<Response> {
[1;31m         self.count.save(ctx.deps.storage, &value)?;
[1;31m         Ok(Response::new())
[0;30m     }
[0;30m
[0;30m     #[sv::msg(query)]
[1;32m     fn value(&self, ctx: QueryCtx) -> StdResult<CounterResponse> {
[1;32m         let value = self.count.load(ctx.deps.storage)?;
[0;30m         Ok(CounterResponse { value })
[0;30m     }
[0;30m }
```

The code coverage report reflects exactly the scope of the first test.<br/> The
`#[sv::msg(instantiate)]` and `#[sv::msg(query)]` entry-points of the contract were executed. There
is one more message variant (line 24) to be tested during contract instantiation and this will be
covered in the next test.<br/> The `#[sv::msg(exec)]` entry-points were not called in this test and
still `[1;31mshine red{:ansi}` in the coverage report.

### Testing initialization with a specific value

The second test verifies the initialization of the **counter** contract using a specific value that
must be in range \[0..255\]. For the purpose of this example, let say it will be **12**.
Initialization with a specific value is done using the `CounterInitMsg::Set{:rust}` message.

```rust copy showLineNumbers{22} filename="test_counter.rs" /CounterInitMsg::Set(12)/
#[test]
fn instantiating_with_value_should_work() {
    let app = App::default();

    let code_id = CodeId::store_code(&app);

    let owner = "owner".into_addr();

    let contract = code_id
        .instantiate(CounterInitMsg::Set(12))
        .call(&owner)
        .unwrap();

    assert_eq!(12, contract.value().unwrap().value);
}
```

Except for the message used to instantiate the contract and the value assertion, all steps in this
test are the same as in the previous one, but let's summarize them shortly:

<Steps>
#### Chain initialization

The chain `App{:rust}` is initialized using the `default{:rust}` function.

```rust showLineNumbers{24} filename="test_counter.rs"
let app = App::default();
```

#### Storing contract on chain

Contract code is stored on chain using `store_code{:rust}` function provided by `CodeId{:rust}`.
Result is assigned to `code_id{:rust}` for later use.

```rust showLineNumbers{26} filename="test_counter.rs"
let code_id = CodeId::store_code(&app);
```

#### Defining the contract owner

The `owner{:rust}` variable is assigned an address of the contract instance's owner.

```rust showLineNumbers{28} filename="test_counter.rs"
let owner = "owner".into_addr();
```

#### Contract instantiation

This time the contract is instantiated using `CounterInitMsg::Set{:rust}` message passed to
`instantiate{:rust}` function provided by `code_id{:rust}`:

```rust showLineNumbers{30} filename="test_counter.rs" /CounterInitMsg::Set(12)/
let contract = code_id
    .instantiate(CounterInitMsg::Set(12))
    .call(&owner)
    .unwrap();
```

#### Querying the contract

Like in the previous test the contract is queried to retrieve the current value of the counter.

```rust showLineNumbers{35} filename="test_counter.rs" /contract.value()/
assert_eq!(12, contract.value().unwrap().value);
```

#### Asserting the value

The expected value of the counter should be **12**.

```rust showLineNumbers{35} filename="test_counter.rs" /assert_eq!(12/
assert_eq!(12, contract.value().unwrap().value);
```

</Steps>

#### Running tests

To execute all test type in terminal:

```shell copy filename="TERMINAL"
cargo test
```

The expected output should be similar to the one shown below. Both tests pass.

```ansi filename="OUTPUT"
     [32;1mRunning[0m tests/mod.rs (target/debug/deps/mod-a819a838d5b2d67d)

running 2 tests
test multitest::test_counter::instantiating_with_zero_should_work ... [32;1mok[0m
test multitest::test_counter::instantiating_with_value_should_work ... [32;1mok[0m

test result: [32;1mok[0m. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

#### Code coverage

To make sure that the entire `#[sv::msg(instantiate)]` entry-point is tested, let's run the code
coverage:

```shell copy filename="TERMINAL"
./coverage.sh
```

```ansi filename="OUTPUT"
|| Tested/Total Lines:
|| src/contract.rs: 9/22
||
40.91% coverage, 9/22 lines covered
```

The detailed code coverage report (similar to the one generated by Tarpaulin) is shown below:

```ansi {30-33,35,39-42,44,48-50} showLineNumbers filename="CODE COVERAGE REPORT (Sylvia version)"
[0;30m use crate::msg::{CounterInitMsg, CounterResponse};
[0;30m use cosmwasm_std::{Response, StdResult};
[0;30m use cw_storage_plus::Item;
[0;30m use sylvia::contract;
[0;30m use sylvia::types::{ExecCtx, InstantiateCtx, QueryCtx};
[0;30m
[0;30m pub struct CounterContract {
[0;30m     pub count: Item<u8>,
[0;30m }
[0;30m
[0;30m #[cfg_attr(not(feature = "library"), sylvia::entry_points)]
[0;30m #[contract]
[0;30m impl CounterContract {
[1;32m     pub const fn new() -> Self {
[0;30m         Self {
[1;32m             count: Item::new("count"),
[0;30m         }
[0;30m     }
[0;30m
[0;30m     #[sv::msg(instantiate)]
[1;32m     fn init(&self, ctx: InstantiateCtx, msg: CounterInitMsg) -> StdResult<Response> {
[1;32m         match msg {
[1;32m             CounterInitMsg::Zero => self.count.save(ctx.deps.storage, &0)?,
[1;32m             CounterInitMsg::Set(value) => self.count.save(ctx.deps.storage, &value)?,
[0;30m         }
[1;32m         Ok(Response::new())
[0;30m     }
[0;30m
[0;30m     #[sv::msg(exec)]
[1;31m     fn inc(&self, ctx: ExecCtx) -> StdResult<Response> {
[1;31m         self.count
[1;31m             .update(ctx.deps.storage, |count| -> StdResult<u8> {
[1;31m                 Ok(count.saturating_add(1))
[0;30m             })?;
[1;31m         Ok(Response::new())
[0;30m     }
[0;30m
[0;30m     #[sv::msg(exec)]
[1;31m     fn dec(&self, ctx: ExecCtx) -> StdResult<Response> {
[1;31m         self.count
[1;31m             .update(ctx.deps.storage, |count| -> StdResult<u8> {
[1;31m                 Ok(count.saturating_sub(1))
[0;30m             })?;
[1;31m         Ok(Response::new())
[0;30m     }
[0;30m
[0;30m     #[sv::msg(exec)]
[1;31m     fn set(&self, ctx: ExecCtx, value: u8) -> StdResult<Response> {
[1;31m         self.count.save(ctx.deps.storage, &value)?;
[1;31m         Ok(Response::new())
[0;30m     }
[0;30m
[0;30m     #[sv::msg(query)]
[1;32m     fn value(&self, ctx: QueryCtx) -> StdResult<CounterResponse> {
[1;32m         let value = self.count.load(ctx.deps.storage)?;
[0;30m         Ok(CounterResponse { value })
[0;30m     }
[0;30m }
```

As expected, the `#[sv::msg(instantiate)]` entry-point is fully tested, including all initialization
message variants. However, the `#[sv::msg(exec)]` entry-points still `[1;31mshine red{:ansi}`. Let's
address this in the next test.

## Testing counter increment

### Testing increment by 1

```rust copy showLineNumbers{38} filename="test_counter.rs"
#[test]
fn incrementing_should_work() {
    let app = App::default();

    let code_id = CodeId::store_code(&app);

    let owner = "owner".into_addr();

    let contract = code_id
        .instantiate(CounterInitMsg::Zero)
        .call(&owner)
        .unwrap();

    contract.inc().call(&owner).unwrap();

    assert_eq!(1, contract.value().unwrap().value);
}
```

`â˜•` Topics to cover

#### Running tests

```shell copy filename="TERMINAL"
cargo test
```

```ansi filename="OUTPUT"
     [32;1mRunning[0m tests/mod.rs (target/debug/deps/mod-a819a838d5b2d67d)

running 3 tests
test multitest::test_counter::instantiating_with_zero_should_work ... [32;1mok[0m
test multitest::test_counter::instantiating_with_value_should_work ... [32;1mok[0m
test multitest::test_counter::incrementing_should_work ... [32;1mok[0m

test result: [32;1mok[0m. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

#### Code coverage

```shell copy filename="TERMINAL"
./coverage.sh
```

```ansi filename="OUTPUT"
|| Tested/Total Lines:
|| src/contract.rs: 14/22
||
63.64% coverage, 14/22 lines covered
```

```ansi {39-42,44,48-50} showLineNumbers filename="CODE COVERAGE REPORT (Sylvia version)"
[0;30m use crate::msg::{CounterInitMsg, CounterResponse};
[0;30m use cosmwasm_std::{Response, StdResult};
[0;30m use cw_storage_plus::Item;
[0;30m use sylvia::contract;
[0;30m use sylvia::types::{ExecCtx, InstantiateCtx, QueryCtx};
[0;30m
[0;30m pub struct CounterContract {
[0;30m     pub count: Item<u8>,
[0;30m }
[0;30m
[0;30m #[cfg_attr(not(feature = "library"), sylvia::entry_points)]
[0;30m #[contract]
[0;30m impl CounterContract {
[1;32m     pub const fn new() -> Self {
[0;30m         Self {
[1;32m             count: Item::new("count"),
[0;30m         }
[0;30m     }
[0;30m
[0;30m     #[sv::msg(instantiate)]
[1;32m     fn init(&self, ctx: InstantiateCtx, msg: CounterInitMsg) -> StdResult<Response> {
[1;32m         match msg {
[1;32m             CounterInitMsg::Zero => self.count.save(ctx.deps.storage, &0)?,
[1;32m             CounterInitMsg::Set(value) => self.count.save(ctx.deps.storage, &value)?,
[0;30m         }
[1;32m         Ok(Response::new())
[0;30m     }
[0;30m
[0;30m     #[sv::msg(exec)]
[1;32m     fn inc(&self, ctx: ExecCtx) -> StdResult<Response> {
[1;32m         self.count
[1;32m             .update(ctx.deps.storage, |count| -> StdResult<u8> {
[1;32m                 Ok(count.saturating_add(1))
[0;30m             })?;
[1;32m         Ok(Response::new())
[0;30m     }
[0;30m
[0;30m     #[sv::msg(exec)]
[1;31m     fn dec(&self, ctx: ExecCtx) -> StdResult<Response> {
[1;31m         self.count
[1;31m             .update(ctx.deps.storage, |count| -> StdResult<u8> {
[1;31m                 Ok(count.saturating_sub(1))
[0;30m             })?;
[1;31m         Ok(Response::new())
[0;30m     }
[0;30m
[0;30m     #[sv::msg(exec)]
[1;31m     fn set(&self, ctx: ExecCtx, value: u8) -> StdResult<Response> {
[1;31m         self.count.save(ctx.deps.storage, &value)?;
[1;31m         Ok(Response::new())
[0;30m     }
[0;30m
[0;30m     #[sv::msg(query)]
[1;32m     fn value(&self, ctx: QueryCtx) -> StdResult<CounterResponse> {
[1;32m         let value = self.count.load(ctx.deps.storage)?;
[0;30m         Ok(CounterResponse { value })
[0;30m     }
[0;30m }
```

`â˜•` Comment the coverage report

### Testing increment overflow

```rust copy showLineNumbers{56} filename="test_counter.rs"
#[test]
fn incrementing_should_stop_at_maximum() {
    let app = App::default();

    let code_id = CodeId::store_code(&app);

    let owner = "owner".into_addr();

    let contract = code_id
        .instantiate(CounterInitMsg::Set(250))
        .call(&owner)
        .unwrap();

    for _ in 1..=10 {
        contract.inc().call(&owner).unwrap();
    }

    assert_eq!(255, contract.value().unwrap().value);
}
```

`â˜•` Topics to cover

#### Running tests

```shell copy filename="TERMINAL"
cargo test
```

```ansi filename="OUTPUT"
     [32;1mRunning[0m tests/mod.rs (target/debug/deps/mod-a819a838d5b2d67d)

running 4 tests
test multitest::test_counter::instantiating_with_zero_should_work ... [32;1mok[0m
test multitest::test_counter::instantiating_with_value_should_work ... [32;1mok[0m
test multitest::test_counter::incrementing_should_work ... [32;1mok[0m
test multitest::test_counter::incrementing_should_stop_at_maximum ... [32;1mok[0m

test result: [32;1mok[0m. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

#### Code coverage

```shell copy filename="TERMINAL"
./coverage.sh
```

```ansi filename="OUTPUT"
|| Tested/Total Lines:
|| src/contract.rs: 14/22
||
63.64% coverage, 14/22 lines covered
```

The code coverage did not change after adding this test case, but a very important use case was
tested: handling overflow during counter incrementation.

## Testing counter decrement

### Testing decrement by 1

```rust copy showLineNumbers{76} filename="test_counter.rs"
#[test]
fn decrementing_should_work() {
    let app = App::default();

    let code_id = CodeId::store_code(&app);

    let owner = "owner".into_addr();

    let contract = code_id
        .instantiate(CounterInitMsg::Set(126))
        .call(&owner)
        .unwrap();

    contract.dec().call(&owner).unwrap();

    assert_eq!(125, contract.value().unwrap().value);
}
```

`â˜•` Topics to cover

#### Running tests

```shell copy filename="TERMINAL"
cargo test
```

```ansi filename="OUTPUT"
     [32;1mRunning[0m tests/mod.rs (target/debug/deps/mod-a819a838d5b2d67d)

running 5 tests
test multitest::test_counter::instantiating_with_zero_should_work ... [32;1mok[0m
test multitest::test_counter::instantiating_with_value_should_work ... [32;1mok[0m
test multitest::test_counter::incrementing_should_work ... [32;1mok[0m
test multitest::test_counter::incrementing_should_stop_at_maximum ... [32;1mok[0m
test multitest::test_counter::decrementing_should_work ... [32;1mok[0m

test result: [32;1mok[0m. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

#### Code coverage

```shell copy filename="TERMINAL"
./coverage.sh
```

```ansi filename="OUTPUT"
|| Tested/Total Lines:
|| src/contract.rs: 19/22
||
86.36% coverage, 19/22 lines covered
```

```ansi {48-50} showLineNumbers filename="CODE COVERAGE REPORT (Sylvia version)"
[0;30m use crate::msg::{CounterInitMsg, CounterResponse};
[0;30m use cosmwasm_std::{Response, StdResult};
[0;30m use cw_storage_plus::Item;
[0;30m use sylvia::contract;
[0;30m use sylvia::types::{ExecCtx, InstantiateCtx, QueryCtx};
[0;30m
[0;30m pub struct CounterContract {
[0;30m     pub count: Item<u8>,
[0;30m }
[0;30m
[0;30m #[cfg_attr(not(feature = "library"), sylvia::entry_points)]
[0;30m #[contract]
[0;30m impl CounterContract {
[1;32m     pub const fn new() -> Self {
[0;30m         Self {
[1;32m             count: Item::new("count"),
[0;30m         }
[0;30m     }
[0;30m
[0;30m     #[sv::msg(instantiate)]
[1;32m     fn init(&self, ctx: InstantiateCtx, msg: CounterInitMsg) -> StdResult<Response> {
[1;32m         match msg {
[1;32m             CounterInitMsg::Zero => self.count.save(ctx.deps.storage, &0)?,
[1;32m             CounterInitMsg::Set(value) => self.count.save(ctx.deps.storage, &value)?,
[0;30m         }
[1;32m         Ok(Response::new())
[0;30m     }
[0;30m
[0;30m     #[sv::msg(exec)]
[1;32m     fn inc(&self, ctx: ExecCtx) -> StdResult<Response> {
[1;32m         self.count
[1;32m             .update(ctx.deps.storage, |count| -> StdResult<u8> {
[1;32m                 Ok(count.saturating_add(1))
[0;30m             })?;
[1;32m         Ok(Response::new())
[0;30m     }
[0;30m
[0;30m     #[sv::msg(exec)]
[1;32m     fn dec(&self, ctx: ExecCtx) -> StdResult<Response> {
[1;32m         self.count
[1;32m             .update(ctx.deps.storage, |count| -> StdResult<u8> {
[1;32m                 Ok(count.saturating_sub(1))
[0;30m             })?;
[1;32m         Ok(Response::new())
[0;30m     }
[0;30m
[0;30m     #[sv::msg(exec)]
[1;31m     fn set(&self, ctx: ExecCtx, value: u8) -> StdResult<Response> {
[1;31m         self.count.save(ctx.deps.storage, &value)?;
[1;31m         Ok(Response::new())
[0;30m     }
[0;30m
[0;30m     #[sv::msg(query)]
[1;32m     fn value(&self, ctx: QueryCtx) -> StdResult<CounterResponse> {
[1;32m         let value = self.count.load(ctx.deps.storage)?;
[0;30m         Ok(CounterResponse { value })
[0;30m     }
[0;30m }
```

`â˜•` Comment the coverage report

### Testing decrement underflow

```rust copy showLineNumbers{94} filename="test_counter.rs"
#[test]
fn decrementing_should_stop_at_minimum() {
    let app = App::default();

    let code_id = CodeId::store_code(&app);

    let owner = "owner".into_addr();

    let contract = code_id
        .instantiate(CounterInitMsg::Set(5))
        .call(&owner)
        .unwrap();

    for _ in 1..=10 {
        contract.dec().call(&owner).unwrap();
    }

    assert_eq!(0, contract.value().unwrap().value);
}
```

`â˜•` Topics to cover

#### Running tests

```shell copy filename="TERMINAL"
cargo test
```

```ansi filename="OUTPUT"
     [32;1mRunning[0m tests/mod.rs (target/debug/deps/mod-a819a838d5b2d67d)

running 6 tests
test multitest::test_counter::instantiating_with_zero_should_work ... [32;1mok[0m
test multitest::test_counter::instantiating_with_value_should_work ... [32;1mok[0m
test multitest::test_counter::incrementing_should_work ... [32;1mok[0m
test multitest::test_counter::incrementing_should_stop_at_maximum ... [32;1mok[0m
test multitest::test_counter::decrementing_should_work ... [32;1mok[0m
test multitest::test_counter::decrementing_should_stop_at_minimum ... [32;1mok[0m

test result: [32;1mok[0m. 6 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

#### Code coverage

```shell copy filename="TERMINAL"
./coverage.sh
```

```ansi filename="OUTPUT"
|| Tested/Total Lines:
|| src/contract.rs: 19/22
||
86.36% coverage, 19/22 lines covered
```

The code coverage did not change after adding this test case, but a very important use case was
tested: handling underflow during counter decrementation.

## Testing counter value changes

```rust copy showLineNumbers{114} filename="test_counter.rs"
#[test]
fn setting_value_should_work() {
    let app = App::default();

    let code_id = CodeId::store_code(&app);

    let owner = "owner".into_addr();

    let contract = code_id
        .instantiate(CounterInitMsg::Set(5))
        .call(&owner)
        .unwrap();

    contract.set(125).call(&owner).unwrap();

    assert_eq!(125, contract.value().unwrap().value);
}
```

`â˜•` Topics to cover

#### Running tests

```shell copy filename="TERMINAL"
cargo test
```

```ansi filename="OUTPUT"
     [32;1mRunning[0m tests/mod.rs (target/debug/deps/mod-a819a838d5b2d67d)

running 7 tests
test multitest::test_counter::instantiating_with_zero_should_work ... [32;1mok[0m
test multitest::test_counter::instantiating_with_value_should_work ... [32;1mok[0m
test multitest::test_counter::incrementing_should_work ... [32;1mok[0m
test multitest::test_counter::incrementing_should_stop_at_maximum ... [32;1mok[0m
test multitest::test_counter::decrementing_should_work ... [32;1mok[0m
test multitest::test_counter::decrementing_should_stop_at_minimum ... [32;1mok[0m
test multitest::test_counter::setting_value_should_work ... [32;1mok[0m

test result: [32;1mok[0m. 7 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

#### Code coverage

```shell copy filename="TERMINAL"
./coverage.sh
```

```ansi filename="OUTPUT"
|| Tested/Total Lines:
|| src/contract.rs: 22/22
||
100.00% coverage, 22/22 lines covered
```

Nice, you have reached ðŸ’¯% code coverage.

```ansi showLineNumbers filename="CODE COVERAGE REPORT (Sylvia version)"
[0;30m use crate::msg::{CounterInitMsg, CounterResponse};
[0;30m use cosmwasm_std::{Response, StdResult};
[0;30m use cw_storage_plus::Item;
[0;30m use sylvia::contract;
[0;30m use sylvia::types::{ExecCtx, InstantiateCtx, QueryCtx};
[0;30m
[0;30m pub struct CounterContract {
[0;30m     pub count: Item<u8>,
[0;30m }
[0;30m
[0;30m #[cfg_attr(not(feature = "library"), sylvia::entry_points)]
[0;30m #[contract]
[0;30m impl CounterContract {
[1;32m     pub const fn new() -> Self {
[0;30m         Self {
[1;32m             count: Item::new("count"),
[0;30m         }
[0;30m     }
[0;30m
[0;30m     #[sv::msg(instantiate)]
[1;32m     fn init(&self, ctx: InstantiateCtx, msg: CounterInitMsg) -> StdResult<Response> {
[1;32m         match msg {
[1;32m             CounterInitMsg::Zero => self.count.save(ctx.deps.storage, &0)?,
[1;32m             CounterInitMsg::Set(value) => self.count.save(ctx.deps.storage, &value)?,
[0;30m         }
[1;32m         Ok(Response::new())
[0;30m     }
[0;30m
[0;30m     #[sv::msg(exec)]
[1;32m     fn inc(&self, ctx: ExecCtx) -> StdResult<Response> {
[1;32m         self.count
[1;32m             .update(ctx.deps.storage, |count| -> StdResult<u8> {
[1;32m                 Ok(count.saturating_add(1))
[0;30m             })?;
[1;32m         Ok(Response::new())
[0;30m     }
[0;30m
[0;30m     #[sv::msg(exec)]
[1;32m     fn dec(&self, ctx: ExecCtx) -> StdResult<Response> {
[1;32m         self.count
[1;32m             .update(ctx.deps.storage, |count| -> StdResult<u8> {
[1;32m                 Ok(count.saturating_sub(1))
[0;30m             })?;
[1;32m         Ok(Response::new())
[0;30m     }
[0;30m
[0;30m     #[sv::msg(exec)]
[1;32m     fn set(&self, ctx: ExecCtx, value: u8) -> StdResult<Response> {
[1;32m         self.count.save(ctx.deps.storage, &value)?;
[1;32m         Ok(Response::new())
[0;30m     }
[0;30m
[0;30m     #[sv::msg(query)]
[1;32m     fn value(&self, ctx: QueryCtx) -> StdResult<CounterResponse> {
[1;32m         let value = self.count.load(ctx.deps.storage)?;
[0;30m         Ok(CounterResponse { value })
[0;30m     }
[0;30m }
```

All functionalities of the **counter** smart contract has been tested.

## Test cases put all together

Below is the final version of the `test_counter.rs` file, containing all previously presented test
cases for the **counter** smart contract written using the Sylvia framework.

```rust copy showLineNumbers filename="test_counter.rs"
use counter::contract::sv::mt::{CodeId, CounterContractProxy};
use counter::msg::CounterInitMsg;
use sylvia::cw_multi_test::IntoAddr;
use sylvia::multitest::App;

#[test]
fn instantiating_with_zero_should_work() {
    let app = App::default();

    let code_id = CodeId::store_code(&app);

    let owner = "owner".into_addr();

    let contract = code_id
        .instantiate(CounterInitMsg::Zero)
        .call(&owner)
        .unwrap();

    assert_eq!(0, contract.value().unwrap().value);
}

#[test]
fn instantiating_with_value_should_work() {
    let app = App::default();

    let code_id = CodeId::store_code(&app);

    let owner = "owner".into_addr();

    let contract = code_id
        .instantiate(CounterInitMsg::Set(12))
        .call(&owner)
        .unwrap();

    assert_eq!(12, contract.value().unwrap().value);
}

#[test]
fn incrementing_should_work() {
    let app = App::default();

    let code_id = CodeId::store_code(&app);

    let owner = "owner".into_addr();

    let contract = code_id
        .instantiate(CounterInitMsg::Zero)
        .call(&owner)
        .unwrap();

    contract.inc().call(&owner).unwrap();

    assert_eq!(1, contract.value().unwrap().value);
}

#[test]
fn incrementing_should_stop_at_maximum() {
    let app = App::default();

    let code_id = CodeId::store_code(&app);

    let owner = "owner".into_addr();

    let contract = code_id
        .instantiate(CounterInitMsg::Set(250))
        .call(&owner)
        .unwrap();

    for _ in 1..=10 {
        contract.inc().call(&owner).unwrap();
    }

    assert_eq!(255, contract.value().unwrap().value);
}

#[test]
fn decrementing_should_work() {
    let app = App::default();

    let code_id = CodeId::store_code(&app);

    let owner = "owner".into_addr();

    let contract = code_id
        .instantiate(CounterInitMsg::Set(126))
        .call(&owner)
        .unwrap();

    contract.dec().call(&owner).unwrap();

    assert_eq!(125, contract.value().unwrap().value);
}

#[test]
fn decrementing_should_stop_at_minimum() {
    let app = App::default();

    let code_id = CodeId::store_code(&app);

    let owner = "owner".into_addr();

    let contract = code_id
        .instantiate(CounterInitMsg::Set(5))
        .call(&owner)
        .unwrap();

    for _ in 1..=10 {
        contract.dec().call(&owner).unwrap();
    }

    assert_eq!(0, contract.value().unwrap().value);
}

#[test]
fn setting_value_should_work() {
    let app = App::default();

    let code_id = CodeId::store_code(&app);

    let owner = "owner".into_addr();

    let contract = code_id
        .instantiate(CounterInitMsg::Set(5))
        .call(&owner)
        .unwrap();

    contract.set(125).call(&owner).unwrap();

    assert_eq!(125, contract.value().unwrap().value);
}
```

## Summary

`â˜•` Write summary

<Cards>
  <Card
    title="Writing tests for counter smart contract written using pure CosmWasm libraries"
    href="writing-tests/writing-tests-cosmwasm"
    icon=""
    children=""
  />
</Cards>
