---
tags: ["multitest", "smart contract", "example"]
---

import { Callout } from "nextra/components";

# Smart contract

The following sections describe how to create the example smart contract, which manages a counter
that can be initialized, incremented, decremented, and queried. Later, you will
[write tests](writing-tests.mdx) for this contract using **`MultiTest`**.

<Callout type="info">
  This example smart contract is a simplified version of the contract created using
  [cw-template](/core/installation#setting-up-the-contract).
</Callout>

## Creating project

Smart contracts written in Rust are typically developed as Rust libraries, so let's first create a
Rust library named **counter**.

Change the working directory to your home directory:

```shell copy
cd ~
```

Create a dedicated directory to store your example smart contract:

```shell copy
mkdir my-contracts
```

Change the working directory to `my-contracts`:

```shell copy
cd my-contracts
```

Create a new Rust library named **counter**:

```shell copy
cargo init --lib counter
```

Change the working directory to `counter`:

```shell copy
cd counter
```

Newly created library contains the **Cargo.toml** file and **lib.rs** file in `src` directory...

```shell copy
tree
```

...so expected content of the `counter` directory is:

```ansi filename="counter"
[34;1m.[0m
â”œâ”€â”€Â Cargo.toml
â””â”€â”€Â [34;1msrc[0m
Â Â Â Â â””â”€â”€ lib.rs

2Â directories,Â 2Â files
```

By convention, the source code of the smart contract is placed in file named **contract.rs**, and
the messages processed by this contract are placed in file named **msg.rs**, both in `src`
directory.

Let's create the **contract.rs** file...

```shell copy
touch src/contract.rs
```

...and **msg.rs** file:

```shell copy
touch src/msg.rs
```

The final structure of the smart contract project placed in `counter` directory, should look like
shown below:

```shell copy
tree
```

```ansi filename="counter"
[34;1m.[0m
â”œâ”€â”€Â Cargo.toml
â””â”€â”€Â [34;1msrc[0m
Â Â Â Â â”œâ”€â”€ contract.rs
Â Â Â Â â”œâ”€â”€ lib.rs
Â Â Â Â â””â”€â”€ msg.rs

2Â directories,Â 4Â files
```

## Filling the content

The following code snippets show the content of the **Cargo.toml**, **lib.rs**, **msg.rs** and
**contract.rs** files, respectively. You can copy and paste this content, temporarily skipping the
detailed explanations. However, if you're curious about what happens inside each file, feel free to
check the detailed descriptions provided below each snippet.

```toml filename="Cargo.toml" copy
[package]
name = "counter"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib", "rlib"]

[features]
# use library feature to disable all instantiate/execute/query exports
library = []

[dependencies]
cosmwasm-schema = "2"
cosmwasm-std = { version = "2" }
cw-storage-plus = "2"
schemars = "0.8"
serde = "1.0"

[dev-dependencies]
cw-multi-test = { version = "2", features = ["cosmwasm_2_0"] }
```

<details>
  <summary>Detailed explanation of the &#8203;**Cargo.toml**&#8203; content</summary>
  (tbd)
</details>

```rust filename="lib.rs" copy
pub mod contract;
pub mod msg;
```

<details>
  <summary>Detailed explanation of the &#8203;**lib.rs**&#8203; content</summary>
  (tbd)
</details>

```rust filename="msg.rs" copy
use cosmwasm_schema::cw_serde;

#[cw_serde]
pub enum CounterInitMsg {
    Zero,
    Set(u8),
}

#[cw_serde]
pub enum CounterActionMsg {
    Inc,
    Dec,
    Set(u8),
}

#[cw_serde]
pub enum CounterQuery {
    Value,
}

#[cw_serde]
pub struct CounterResponse {
    pub value: u8,
}
```

<details>
  <summary>Detailed explanation of the &#8203;**msg.rs**&#8203; content</summary>
  (tbd)
</details>

```rust filename="contract.rs" copy
#[cfg(not(feature = "library"))]
use cosmwasm_std::entry_point;

use crate::msg::{
    CounterActionMsg, CounterInitMsg, CounterQuery, CounterResponse,
};
use cosmwasm_std::{
    to_json_binary, Binary, Deps, DepsMut, Env, MessageInfo, Response, StdError,
};
use cw_storage_plus::Item;

const COUNTER: Item<u8> = Item::new("value");

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn instantiate(
    deps: DepsMut,
    _env: Env,
    _info: MessageInfo,
    msg: CounterInitMsg,
) -> Result<Response, StdError> {
    COUNTER.save(
        deps.storage,
        &match msg {
            CounterInitMsg::Zero => 0,
            CounterInitMsg::Set(value) => value,
        },
    )?;
    Ok(Response::default())
}

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn execute(
    deps: DepsMut,
    _env: Env,
    _info: MessageInfo,
    msg: CounterActionMsg,
) -> Result<Response, StdError> {
    COUNTER.update::<_, StdError>(deps.storage, |old_value| {
        Ok(match msg {
            CounterActionMsg::Inc => old_value.saturating_add(1),
            CounterActionMsg::Dec => old_value.saturating_sub(1),
            CounterActionMsg::Set(new_value) => new_value,
        })
    })?;
    Ok(Response::default())
}

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn query(
    deps: Deps,
    _env: Env,
    msg: CounterQuery,
) -> Result<Binary, StdError> {
    match msg {
        CounterQuery::Value => Ok(to_json_binary(&CounterResponse {
            value: COUNTER.may_load(deps.storage).unwrap().unwrap(),
        })?),
    }
}
```

<details>
  <summary>Detailed explanation of the &#8203;**contract.rs**&#8203; content</summary>
  (tbd)
</details>

## Building smart contract

With the example **counter** smart contract set up, you can now build the project:

```shell copy
cargo build
```

```ansi
Â [32;1mUpdating[0mÂ crates.ioÂ index
Â Â [32;1mLocking[0mÂ 112Â packagesÂ toÂ latestÂ compatibleÂ versions
Â Â Â Â â‹®
[32;1mCompiling[0mÂ cosmwasm-cryptoÂ v2.1.3
[32;1mCompiling[0mÂ cosmwasm-stdÂ v2.1.3
[32;1mCompiling[0mÂ cw-storage-plusÂ v2.0.0
[32;1mCompiling[0mÂ counterÂ v0.1.0Â (/home/user/my-contracts/counter)
Â [32;1mFinished[0mÂ `dev`Â profileÂ [unoptimizedÂ +Â debuginfo]Â target(s)Â inÂ 3.27s
```

**counter** smart contract is built, let's [write some tests](writing-tests.mdx) using
**`MultiTest`**Â !
