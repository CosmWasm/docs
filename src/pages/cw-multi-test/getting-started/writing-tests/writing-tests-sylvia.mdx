---
tags: ["multitest", "getting started", "tests", "CosmWasm"]
---

import { Callout, Steps } from "nextra/components";

# Writing tests in Sylvia

As a reminder, the file structure of the **counter** project is shown below. In this chapter, you
will be writing tests for this smart contract, which will be placed in a file named
`test_counter.rs`, highlighted in **line 12**.

```ansi {12} showLineNumbers filename="counter (directory)"
[34;1m.[0m
├── Cargo.toml
├── [32;1mcoverage.sh[0m
├── [34;1msrc[0m
│   ├── contract.rs
│   ├── lib.rs
│   └── msg.rs
└── [34;1mtests[0m
    ├── mod.rs
    └── [34;1mmultitest[0m
        ├── mod.rs
        └── test_counter.rs
```

<Callout emoji="🏃">
  If you're in a hurry, at the end of this chapter, you can find the [full
  version](#test-cases-put-all-together) of the `test_counter.rs` file. Just copy and paste its
  content and run all tests.
</Callout>

## Imports

```rust copy showLineNumbers filename="test_counter.rs"
use counter::contract::sv::mt::{CodeId, CounterContractProxy};
use counter::msg::CounterInitMsg;
use sylvia::cw_multi_test::IntoAddr;
use sylvia::multitest::App;
```

## Testing counter initialization

### Testing initialization with zero

```rust copy showLineNumbers{6} filename="test_counter.rs"
#[test]
fn instantiating_with_zero_should_work() {
    let app = App::default();
    let code_id = CodeId::store_code(&app);

    let owner = "owner".into_addr();
    let contract = code_id
        .instantiate(CounterInitMsg::Zero)
        .call(&owner)
        .unwrap();

    assert_eq!(0, contract.count().unwrap().count);
}
```

### Testing initialization with a specific value

```rust copy showLineNumbers{20} filename="test_counter.rs"
#[test]
fn instantiating_with_value_should_work() {
    let app = App::default();
    let code_id = CodeId::store_code(&app);

    let owner = "owner".into_addr();
    let contract = code_id
        .instantiate(CounterInitMsg::Set(12))
        .call(&owner)
        .unwrap();

    assert_eq!(12, contract.count().unwrap().count);
}
```

## Testing counter increment

### Testing increment by 1

```rust copy showLineNumbers{34} filename="test_counter.rs"
#[test]
fn incrementing_should_work() {
    let app = App::default();
    let code_id = CodeId::store_code(&app);

    let owner = "owner".into_addr();
    let contract = code_id
        .instantiate(CounterInitMsg::Zero)
        .call(&owner)
        .unwrap();

    contract.inc().call(&owner).unwrap();

    assert_eq!(1, contract.count().unwrap().count);
}
```

### Testing increment overflow

```rust copy showLineNumbers{50} filename="test_counter.rs"
#[test]
fn incrementing_should_stop_at_maximum() {
    let app = App::default();
    let code_id = CodeId::store_code(&app);

    let owner = "owner".into_addr();
    let contract = code_id
        .instantiate(CounterInitMsg::Set(250))
        .call(&owner)
        .unwrap();

    for _ in 1..=10 {
        contract.inc().call(&owner).unwrap();
    }

    assert_eq!(255, contract.count().unwrap().count);
}
```

## Testing counter decrement

### Testing decrement by 1

```rust copy showLineNumbers{68} filename="test_counter.rs"
#[test]
fn decrementing_should_work() {
    let app = App::default();
    let code_id = CodeId::store_code(&app);

    let owner = "owner".into_addr();
    let contract = code_id
        .instantiate(CounterInitMsg::Set(126))
        .call(&owner)
        .unwrap();

    contract.dec().call(&owner).unwrap();

    assert_eq!(125, contract.count().unwrap().count);
}
```

### Testing decrement underflow

```rust copy showLineNumbers{84} filename="test_counter.rs"
#[test]
fn decrementing_should_stop_at_minimum() {
    let app = App::default();
    let code_id = CodeId::store_code(&app);

    let owner = "owner".into_addr();
    let contract = code_id
        .instantiate(CounterInitMsg::Set(5))
        .call(&owner)
        .unwrap();

    for _ in 1..=10 {
        contract.dec().call(&owner).unwrap();
    }

    assert_eq!(0, contract.count().unwrap().count);
}
```

## Testing counter value changes

```rust copy showLineNumbers{102} filename="test_counter.rs"
#[test]
fn setting_value_should_work() {
    let app = App::default();
    let code_id = CodeId::store_code(&app);

    let owner = "owner".into_addr();
    let contract = code_id
        .instantiate(CounterInitMsg::Set(5))
        .call(&owner)
        .unwrap();

    contract.set(125).call(&owner).unwrap();

    assert_eq!(125, contract.count().unwrap().count);
}
```

## Test cases put all together

Below is the final content of the `test_counter.rs` file, containing all previously presented test
cases for smart contract written in Sylvia.

```rust copy showLineNumbers filename="test_counter.rs"
use counter::contract::sv::mt::{CodeId, CounterContractProxy};
use counter::msg::CounterInitMsg;
use sylvia::cw_multi_test::IntoAddr;
use sylvia::multitest::App;

#[test]
fn instantiating_with_zero_should_work() {
    let app = App::default();
    let code_id = CodeId::store_code(&app);

    let owner = "owner".into_addr();
    let contract = code_id
        .instantiate(CounterInitMsg::Zero)
        .call(&owner)
        .unwrap();

    assert_eq!(0, contract.count().unwrap().count);
}

#[test]
fn instantiating_with_value_should_work() {
    let app = App::default();
    let code_id = CodeId::store_code(&app);

    let owner = "owner".into_addr();
    let contract = code_id
        .instantiate(CounterInitMsg::Set(12))
        .call(&owner)
        .unwrap();

    assert_eq!(12, contract.count().unwrap().count);
}

#[test]
fn incrementing_should_work() {
    let app = App::default();
    let code_id = CodeId::store_code(&app);

    let owner = "owner".into_addr();
    let contract = code_id
        .instantiate(CounterInitMsg::Zero)
        .call(&owner)
        .unwrap();

    contract.inc().call(&owner).unwrap();

    assert_eq!(1, contract.count().unwrap().count);
}

#[test]
fn incrementing_should_stop_at_maximum() {
    let app = App::default();
    let code_id = CodeId::store_code(&app);

    let owner = "owner".into_addr();
    let contract = code_id
        .instantiate(CounterInitMsg::Set(250))
        .call(&owner)
        .unwrap();

    for _ in 1..=10 {
        contract.inc().call(&owner).unwrap();
    }

    assert_eq!(255, contract.count().unwrap().count);
}

#[test]
fn decrementing_should_work() {
    let app = App::default();
    let code_id = CodeId::store_code(&app);

    let owner = "owner".into_addr();
    let contract = code_id
        .instantiate(CounterInitMsg::Set(126))
        .call(&owner)
        .unwrap();

    contract.dec().call(&owner).unwrap();

    assert_eq!(125, contract.count().unwrap().count);
}

#[test]
fn decrementing_should_stop_at_minimum() {
    let app = App::default();
    let code_id = CodeId::store_code(&app);

    let owner = "owner".into_addr();
    let contract = code_id
        .instantiate(CounterInitMsg::Set(5))
        .call(&owner)
        .unwrap();

    for _ in 1..=10 {
        contract.dec().call(&owner).unwrap();
    }

    assert_eq!(0, contract.count().unwrap().count);
}

#[test]
fn setting_value_should_work() {
    let app = App::default();
    let code_id = CodeId::store_code(&app);

    let owner = "owner".into_addr();
    let contract = code_id
        .instantiate(CounterInitMsg::Set(5))
        .call(&owner)
        .unwrap();

    contract.set(125).call(&owner).unwrap();

    assert_eq!(125, contract.count().unwrap().count);
}
```

## Test cases summary

(todo: find the best place for this)

<Steps>
  ### Initialize the chain

(todo)

### Store contract's code on chain

(todo)

### Initialize the contract

(todo)

### Interact with the contract

(todo)

### Assert expected results

(todo)

</Steps>
