---
tags: ["sylvia", "macros"]
---

import { Callout } from "nextra/components";

# Entry_points

Use the `entry_points` macro to generate entry points of your contract.

<Callout>
    Use `entry_points` macro on top of `contract` macro. The `contract` macro erases all the Sylvia attributes, which may cause
    the `entry_points` macro to fail. The `entry_points` macro also depends on the messages generated by the `contract` macro.

</Callout>

## Attributes

List of attributes supported by `entry_points` macro:

- [`custom`](../attributes/custom)
- [`error`](../attributes/error)
- [`msg`](../attributes/msg)
- [`override_entry_point`](../attributes/override-entry-point)

## Usage

```rust
use cosmwasm_schema::cw_serde;
use cosmwasm_std::{Response, StdResult};

use sylvia::contract;
use sylvia::types::{ExecCtx, InstantiateCtx};

#[cfg(not(feature = "library"))]
use sylvia::entry_points;

pub struct CounterContract;

#[cw_serde]
pub struct SomeResponse;

#[cfg_attr(not(feature = "library"), entry_points)]
#[contract]
impl CounterContract {
    pub const fn new() -> Self {
        Self
    }

    #[sv::msg(instantiate)]
    fn instantiate(&self, ctx: InstantiateCtx) -> StdResult<Response> {
        Ok(Response::new())
    }

    #[sv::msg(exec)]
    fn some_exec(&self, ctx: ExecCtx) -> StdResult<Response> {
        Ok(Response::new())
    }
}
```

The `entry_points` macro scans for [`sv::msg`](../attributes/msg) attributes. By
default it generates: instantiate, exec, and query entry points.

## Custom types

You can construct your entry points to work with some specific custom types with
the [`sv::custom`](../attributes/custom).

## Generic types

CosmWasm entry points cannot be generic. We are thus forced to provide concrete
types to be used in place of generic types used in the contract.

```rust
use std::marker::PhantomData;

use cosmwasm_schema::cw_serde;
use cosmwasm_std::{Response, StdResult};

use cw_storage_plus::Item;
use sylvia::contract;
use sylvia::types::{CustomMsg, ExecCtx, InstantiateCtx};

#[cfg(not(feature = "library"))]
use sylvia::cw_std::Empty;
#[cfg(not(feature = "library"))]
use sylvia::entry_points;

pub struct CounterContract<ExecParamT, FieldT> {
    field: Item<FieldT>,
    _phantom: PhantomData<ExecParamT>,
}

#[cw_serde]
pub struct SomeResponse;

#[cfg_attr(not(feature = "library"), entry_points(generics<Empty, Empty>))]
#[contract]
impl<ExecParamT, FieldT> CounterContract<ExecParamT, FieldT>
where
    ExecParamT: CustomMsg + 'static,
    FieldT: 'static,
{
    pub const fn new() -> Self {
        Self {
            field: Item::new("field"),
            _phantom: PhantomData,
        }
    }

    #[sv::msg(instantiate)]
    fn instantiate(&self, ctx: InstantiateCtx) -> StdResult<Response> {
        Ok(Response::new())
    }

    #[sv::msg(exec)]
    fn some_exec(&self, ctx: ExecCtx, param: ExecParamT) -> StdResult<Response> {
        Ok(Response::new())
    }
}
```

We do that by adding parantheses after the `entry_points` macro and passing
`generics` attribute with concrete types passed in brackets.

<Callout>
  Remember to pass the types in the order reflecting the order of generics
  defined on the contract.
</Callout>

If the contract uses generic custom types we have to do some more work.

```rust
#[cfg_attr(not(feature = "library"), entry_points(generics<Empty, Empty>, custom(msg=SvCustomMsg, query=SvCustomQuery)))]
```

After coma we have to pass another parameter `custom`, and in the paranthesis
specify which types should be used in place of custom message and custom query.
The syntax reflects one used in the [`custom`](../attributes/custom).

This is required as, for at least now, Sylvia is unable to determine which
concrete types are supposed to be used in place of generic custom types.
