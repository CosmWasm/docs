---
tags: ["multitest", "smart contract", "example"]
---

import { Callout } from "nextra/components";

# Smart contract

The following sections describe how to create the example smart contract, which manages a counter
that can be initialized, incremented, decremented, and queried. Later, you will
[write tests](writing-tests.mdx) for this contract using **`MultiTest`**.

<Callout type="info">
  This example smart contract is a simplified version of the contract created using
  [cw-template](/core/installation#setting-up-the-contract).
</Callout>

## Creating Rust project

Smart contracts written in Rust are typically developed as Rust libraries, so let's first create a
Rust library named **counter**.

Change the working directory to your home directory:

```shell copy
cd ~
```

Create a dedicated directory to store your example smart contract:

```shell copy
mkdir my-contracts
```

Change the working directory to **my-contracts**:

```shell copy
cd my-contracts
```

Create a new Rust library named **counter**:

```shell copy
cargo init --lib counter
```

Change the working directory to **counter**:

```shell copy
cd counter
```

The newly created library should contain the **Cargo.toml** file and **lib.rs** file in **src**
directory.

```shell copy
tree
```

```ansi filename="counter"
[34;1m.[0m
â”œâ”€â”€Â Cargo.toml
â””â”€â”€Â [34;1msrc[0m
Â Â Â Â â””â”€â”€ lib.rs
```

```shell copy
touch src/counter.rs
```

```shell copy
touch src/msg.rs
```

```shell copy
tree
```

```ansi filename="counter"
[34;1m.[0m
â”œâ”€â”€Â Cargo.toml
â””â”€â”€Â [34;1msrc[0m
Â Â Â Â â”œâ”€â”€ contract.rs
Â Â Â Â â”œâ”€â”€ lib.rs
Â Â Â Â â””â”€â”€ msg.rs
```

## Filling the content

```toml filename="Cargo.toml" copy
[package]
name = "counter"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib", "rlib"]

[features]
# use library feature to disable all instantiate/execute/query exports
library = []

[dependencies]
cosmwasm-schema = "2"
cosmwasm-std = { version = "2" }
cw-storage-plus = "2"
schemars = "0.8"
serde = "1.0"

[dev-dependencies]
cw-multi-test = { version = "2", features = ["cosmwasm_2_0"] }
```

<details>
  <summary>Detailed explanation of the &#8203;**Cargo.toml**&#8203; content</summary>
  (explanation)
</details>

```rust filename="lib.rs" copy
pub mod contract;
pub mod msg;
```

<details>
  <summary>Detailed explanation of the &#8203;**lib.rs**&#8203; content</summary>
  (explanation)
</details>

```rust filename="msg.rs" copy
use cosmwasm_schema::cw_serde;

#[cw_serde]
pub enum CounterInitMsg {
    Zero,
    Set(u8),
}

#[cw_serde]
pub enum CounterActionMsg {
    Inc,
    Dec,
    Set(u8),
}

#[cw_serde]
pub enum CounterQuery {
    Value,
}

#[cw_serde]
pub struct CounterResponse {
    pub value: u8,
}
```

<details>
  <summary>Detailed explanation of the &#8203;**msg.rs**&#8203; content</summary>
  (explanation)
</details>

```rust filename="contract.rs" copy
#[cfg(not(feature = "library"))]
use cosmwasm_std::entry_point;

use crate::msg::{
    CounterActionMsg, CounterInitMsg, CounterQuery, CounterResponse,
};
use cosmwasm_std::{
    to_json_binary, Binary, Deps, DepsMut, Env, MessageInfo, Response, StdError,
};
use cw_storage_plus::Item;

const COUNTER: Item<u8> = Item::new("value");

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn instantiate(
    deps: DepsMut,
    _env: Env,
    _info: MessageInfo,
    msg: CounterInitMsg,
) -> Result<Response, StdError> {
    COUNTER.save(
        deps.storage,
        &match msg {
            CounterInitMsg::Zero => 0,
            CounterInitMsg::Set(value) => value,
        },
    )?;
    Ok(Response::default())
}

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn execute(
    deps: DepsMut,
    _env: Env,
    _info: MessageInfo,
    msg: CounterActionMsg,
) -> Result<Response, StdError> {
    COUNTER.update::<_, StdError>(deps.storage, |old_value| {
        Ok(match msg {
            CounterActionMsg::Inc => old_value.saturating_add(1),
            CounterActionMsg::Dec => old_value.saturating_sub(1),
            CounterActionMsg::Set(new_value) => new_value,
        })
    })?;
    Ok(Response::default())
}

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn query(
    deps: Deps,
    _env: Env,
    msg: CounterQuery,
) -> Result<Binary, StdError> {
    match msg {
        CounterQuery::Value => Ok(to_json_binary(&CounterResponse {
            value: COUNTER.may_load(deps.storage).unwrap().unwrap(),
        })?),
    }
}
```

<details>
  <summary>Detailed explanation of the &#8203;**contract.rs**&#8203; content</summary>
  (explanation)
</details>

## Building smart contract

```shell copy
cargo build
```
